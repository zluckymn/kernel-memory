# Semantic Kernel Components Kernel组件

- 12/07/2024




Semantic Kernel provides many different components, that can be used individually or together. This article gives an overview of the different components and explains the relationship between them.
Kernel提供了许多不同的组件，可以单独使用或一起使用。本文概述了不同的组件，并解释了它们之间的关系。



## AI Service Connectors  AI 服务连接器

The Semantic Kernel AI service connectors provide an abstraction layer that exposes multiple AI service types from different providers via a common interface. Supported services include Chat Completion, Text Generation, Embedding Generation, Text to Image, Image to Text, Text to Audio and Audio to Text.
Kernel AI 服务连接器提供了一个抽象层，通过通用接口公开来自不同提供商的多种 AI 服务类型。支持的服务包括聊天完成、文本生成、嵌入生成、文本到图像、图像到文本、文本到音频和音频到文本。

When an implementation is registered with the Kernel, Chat Completion or Text Generation services will be used by default, by any method calls to the kernel. None of the other supported services will be used automatically.
当实现向内核注册时，默认情况下，对内核的任何方法调用都将使用聊天完成或文本生成服务。不会自动使用任何其他受支持的服务。

 Tip  提示

For more information on using AI services see [Adding AI services to Semantic Kernel](https://learn.microsoft.com/en-us/semantic-kernel/concepts/ai-services/).
有关使用 AI 服务的更多信息，请参阅[将 AI 服务添加到Kernel。](https://learn.microsoft.com/en-us/semantic-kernel/concepts/ai-services/)



## Vector Store (Memory) Connectors 矢量存储（内存）连接器

The Semantic Kernel Vector Store connectors provide an abstraction layer that exposes vector stores from different providers via a common interface. The Kernel does not use any registered vector store automatically, but Vector Search can easily be exposed as a plugin to the Kernel in which case the plugin is made available to Prompt Templates and the Chat Completion AI Model.
Kernel向量存储连接器提供了一个抽象层，该层通过通用接口公开来自不同提供程序的向量存储。内核不会自动使用任何已注册的矢量存储，但矢量搜索可以很容易地作为插件公开给内核，在这种情况下，该插件可用于提示模板和聊天完成 AI 模型。

 Tip  提示

For more information on using memory connectors see [Adding AI services to Semantic Kernel](https://learn.microsoft.com/en-us/semantic-kernel/concepts/ai-services/).
有关使用内存连接器的更多信息，请参阅[将 AI 服务添加到Kernel ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/ai-services/)。



## Functions and Plugins  函数和插件

Plugins are named function containers. Each can contain one or more functions. Plugins can be registered with the kernel, which allows the kernel to use them in two ways:
插件被命名为函数容器。每个函数都可以包含一个或多个函数。插件可以在内核中注册，这允许内核以两种方式使用它们：

1. Advertise them to the chat completion AI, so that the AI can choose them for invocation.
   将它们通告给聊天完成 AI，以便 AI 可以选择它们进行调用。
2. Make them available to be called from a template during template rendering.
   在模板渲染期间，使它们可以从模板调用。

Functions can easily be created from many sources, including from native code, OpenAPI specs, `ITextSearch` implementations for RAG scenarios, but also from prompt templates.
可以从许多源轻松创建函数，包括本机代码、OpenAPI 规范、RAG 方案的 `ITextSearch` 实现，也可以从提示模板创建函数。

![PromptTemplates, NativeCode, OpenAPI specs and TextSearch can be turned into plugins.](https://learn.microsoft.com/en-us/semantic-kernel/media/plugins-from-sources.png)

 Tip  提示

For more information on different plugin sources see [What is a Plugin?](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/).
有关不同插件源的更多信息，请参阅[什么是插件？](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/)

 Tip  提示

For more information on advertising plugins to the chat completion AI see [Function calling with chat completion](https://learn.microsoft.com/en-us/semantic-kernel/concepts/ai-services/chat-completion/function-calling/).
有关向聊天完成 AI 通告插件的更多信息，请参阅[使用聊天完成进行函数调用 ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/ai-services/chat-completion/function-calling/)。



## Prompt Templates  提示模板

Prompt templates allow a developer or prompt engineer to create a template that mixes context and instructions for the AI with user input and function output. E.g. the template may contain instructions for the Chat Completion AI model, and placeholders for user input, plus hardcoded calls to plugins that always need to be executed before invoking the Chat Completion AI model.
提示模板允许开发人员或提示工程师创建一个模板，将 AI 的上下文和指令与用户输入和函数输出混合在一起。例如，模板可能包含聊天完成 AI 模型的说明和用户输入的占位符，以及对插件的硬编码调用，这些调用在调用聊天完成 AI 模型之前始终需要执行。

Prompt templates can be used in two ways:
提示模板可以通过两种方式使用：

1. As the starting point of a Chat Completion flow by asking the kernel to render the template and invoke the Chat Completion AI model with the rendered result.
   作为聊天完成流程的起点，要求内核呈现模板，并使用呈现的结果调用聊天完成 AI 模型。
2. As a plugin function, so that it can be invoked in the same way as any other function can be.
   作为插件函数，因此可以像任何其他函数一样调用它。

When a prompt template is used, it will first be rendered, plus any hardcoded function references that it contains will be executed. The rendered prompt will then be passed to the Chat Completion AI model. The result generated by the AI will be returned to the caller. If the prompt template had been registered as a plugin function, the function may have been chosen for execution by the Chat Completion AI model and in this case the caller is Semantic Kernel, on behalf of the AI model.
使用提示模板时，将首先渲染它，并执行它包含的任何硬编码函数引用。然后，呈现的提示将传递给聊天完成 AI 模型。AI 生成的结果将返回给调用者。如果提示模板已注册为插件函数，则该函数可能已被选择由聊天完成 AI 模型执行，在这种情况下，调用方是代表 AI 模型的Kernel。

Using prompt templates as plugin functions in this way can result in rather complex flows. E.g. consider the scenario where a prompt template `A` is registered as a plugin. At the same time a different prompt template `B` may be passed to the kernel to start the chat completion flow. `B` could have a hardcoded call to `A`. This would result in the following steps:
以这种方式使用提示模板作为插件功能可能会导致相当复杂的流程。例如，考虑提示模板 `A` 注册为插件的场景。同时，可以将不同的提示模板 `B` 传递给内核以启动聊天完成流程。`B` 可以对 `A` 进行硬编码调用。这将导致以下步骤：

1. `B` rendering starts and the prompt execution finds a reference to `A`
   `B` 渲染开始，提示执行找到对 `A` 的引用
2. `A` is rendered.  `渲染 A`。
3. The rendered output of `A` is passed to the Chat Completion AI model.
   `A` 的渲染输出将传递给聊天完成 AI 模型。
4. The result of the Chat Completion AI model is returned to `B`.
   聊天完成 AI 模型的结果将返回给 `B`。
5. Rendering of `B` completes.
   `B` 的渲染完成。
6. The rendered output of `B` is passed to the Chat Completion AI model.
   `B` 的渲染输出将传递给聊天完成 AI 模型。
7. The result of the Chat Completion AI model is returned to to the caller.
   聊天完成 AI 模型的结果将返回给调用方。

Also consider the scenario where there is no hardcoded call from `B` to `A`. If function calling is enabled, the Chat Completion AI model may still decide that `A` should be invoked since it requires data or functionality that `A` can provide.
另请考虑没有从 `B` 到 `A` 的硬编码调用的方案。如果启用了函数调用，聊天完成 AI 模型仍可能决定应调用 `A`，因为它需要 `A` 可以提供的数据或功能。

Registering prompt templates as plugin functions allows for the possibility of creating functionality that is described using human language instead of actual code. Separating the functionality into a plugin like this allows the AI model to reason about this separately to the main execution flow, and can lead to higher success rates by the AI model, since it can focus on a single problem at a time.
将提示模板注册为插件函数允许创建使用人类语言而不是实际代码描述的功能。像这样将功能分离到一个插件中，可以让 AI 模型与主执行流程分开推理这一点，并且可以提高 AI 模型的成功率，因为它可以一次专注于一个问题。

See the following diagram for a simple flow that is started from a prompt template.
有关从提示模板启动的简单流，请参阅下图。

![PromptTemplates can be executed by the kernel where it renders the template, invokes any required functions, and then invokes the Chat Completion AI model to get an answer or more functions to invoke.](https://learn.microsoft.com/en-us/semantic-kernel/media/template-function-execution.png)

 Tip  提示

For more information on prompt templates see [What are prompts?](https://learn.microsoft.com/en-us/semantic-kernel/concepts/prompts/).
有关提示模板的详细信息，请参阅[什么是提示？](https://learn.microsoft.com/en-us/semantic-kernel/concepts/prompts/)。



## Filters  过滤 器

Filters provide a way to take custom action before and after specific events during the chat completion flow. These events include:
筛选器提供了一种在聊天完成流程期间在特定事件之前和之后执行自定义作的方法。这些活动包括：

1. Before and after function invocation.
   函数调用之前和之后。
2. Before and after prompt rendering.
   提示渲染前后。

Filters need to be registered with the kernel to get invoked during the chat completion flow.
需要向内核注册过滤器才能在聊天完成流程期间调用。

Note that since prompt templates are always converted to KernelFunctions before execution, both function and prompt filters will be invoked for a prompt template. Since filters are nested when more than one is available, function filters are the outer filters and prompt filters are the inner filters.
请注意，由于提示模板总是在执行前转换为 KernelFunctions，因此将为提示模板调用函数和提示过滤器。由于当有多个过滤器可用时，过滤器是嵌套的，因此函数过滤器是外部过滤器，提示过滤器是内部过滤器。

![Filter integration into the semantic kernel pipeline.](https://learn.microsoft.com/en-us/semantic-kernel/media/filters-overview.png)

 Tip  提示

For more information on filters see [What are Filters?](https://learn.microsoft.com/en-us/semantic-kernel/concepts/enterprise-readiness/filters).
有关过滤器的更多信息，请参阅[什么是过滤器？](https://learn.microsoft.com/en-us/semantic-kernel/concepts/enterprise-readiness/filters)。