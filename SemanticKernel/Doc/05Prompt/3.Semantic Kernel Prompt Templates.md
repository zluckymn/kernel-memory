# Semantic Kernel prompt template syntax Semantic Kernel提示模板语法

- 11/19/2024

The Semantic Kernel prompt template language is a simple way to define and compose AI functions using plain text. You can use it to create natural language prompts, generate responses, extract information, invoke other prompts or perform any other task that can be expressed with text.
Semantic Kernel提示模板语言是一种使用纯文本定义和组合 AI 函数的简单方法。您可以使用它来创建自然语言提示、生成响应、提取信息、调用其他提示或执行任何其他可以用文本表达的任务。

The language supports three basic features that allow you to 1) include variables, 2) call external functions, and 3) pass parameters to functions.
该语言支持三个基本功能，允许您 1） 包含变量，2） 调用外部函数，以及 3） 将参数传递给函数。

You don't need to write any code or import any external libraries, just use the curly braces `{{...}}` to embed expressions in your prompts. Semantic Kernel will parse your template and execute the logic behind it. This way, you can easily integrate AI into your apps with minimal effort and maximum flexibility.
您无需编写任何代码或导入任何外部库，只需使用大括号 `{{...}}` 在提示中嵌入表达式即可。Semantic Kernel将解析您的模板并执行其背后的逻辑。这样，您就可以轻松地将 AI 集成到您的应用程序中，轻松省力且具有最大的灵活性。

 Tip  提示

If you need more capabilities, we also support: [Handlebars](https://handlebarsjs.com/) and [Liquid](https://shopify.github.io/liquid/) template engines, which allows you to use loops, conditionals, and other advanced features.
如果您需要更多功能，我们还支持： [Handlebars](https://handlebarsjs.com/) 和 [Liquid](https://shopify.github.io/liquid/) 模板引擎，允许您使用循环、条件和其他高级功能。



## Variables  变量

To include a variable value in your prompt, use the `{{$variableName}}` syntax. For example, if you have a variable called `name` that holds the user's name, you can write:
要在提示中包含变量值，请使用 `{{$variableName}}` 语法。例如，如果您有一个名为 `name` 的变量来保存用户名，则可以编写：

```
Hello {{$name}}, welcome to Semantic Kernel!
```

This will produce a greeting with the user's name.
这将生成带有用户名称的问候语。

Spaces are ignored, so if you find it more readable, you can also write:
空格被忽略，所以如果你觉得它更易读，你也可以写：

```
Hello {{ $name }}, welcome to Semantic Kernel!
```



## Function calls  函数调用

To call an external function and embed the result in your prompt, use the `{{namespace.functionName}}` syntax. For example, if you have a function called `weather.getForecast` that returns the weather forecast for a given location, you can write:
要调用外部函数并将结果嵌入到提示中，请使用 `{{namespace.functionName}}` 语法。例如，如果您有一个名为 `weather.getForecast` 的函数返回给定位置的天气预报，则可以编写：

```
The weather today is {{weather.getForecast}}.
```

This will produce a sentence with the weather forecast for the default location stored in the `input` variable. The `input` variable is set automatically by the kernel when invoking a function. For instance, the code above is equivalent to:
这将生成一个句子，其中包含存储在`输入`变量中的默认位置的天气预报。` 输入`变量由内核在调用函数时自动设置。例如，上面的代码相当于：

```
The weather today is {{weather.getForecast $input}}.
```



## Function parameters  功能参数

To call an external function and pass a parameter to it, use the `{{namespace.functionName $varName}}` and `{{namespace.functionName "value"}}` syntax. For example, if you want to pass a different input to the weather forecast function, you can write:
要调用外部函数并向其传递参数，请使用 `{{namespace.functionName $varName}}` 和 `{{namespace.functionName "value"}}` 语法。例如，如果要将不同的输入传递给天气预报函数，可以编写：

txtCopy  复制

```txt
The weather today in {{$city}} is {{weather.getForecast $city}}.
The weather today in Schio is {{weather.getForecast "Schio"}}.
```

This will produce two sentences with the weather forecast for two different locations, using the city stored in the `city` variable and the *"Schio"* location value hardcoded in the prompt template.
这将生成两个句子，其中包含两个不同位置的天气预报，使用`存储在城市`变量中的城市和 *“Schio”* 位置值硬编码在提示模板中。



## Notes about special chars 关于特殊字符的注意事项

Semantic function templates are text files, so there is no need to escape special chars like new lines and tabs. However, there are two cases that require a special syntax:
语义函数模板是文本文件，因此无需转义特殊字符，如换行符和制表符。但是，有两种情况需要特殊语法：

1. Including double curly braces in the prompt templates
   在提示模板中包含双大括号
2. Passing to functions hardcoded values that include quotes
   将包含引号的硬编码值传递给函数



## Prompts needing double curly braces 需要双大括号的提示

Double curly braces have a special use case, they are used to inject variables, values, and functions into templates.
双大括号有一个特殊的用例，它们用于将变量、值和函数注入模板中。

If you need to include the **{{** and **}}** sequences in your prompts, which could trigger special rendering logic, the best solution is to use string values enclosed in quotes, like `{{ "{{" }}` and `{{ "}}" }}`
如果您需要在提示中包含 **{{** 和 **}}** 序列，这可能会触发特殊的渲染逻辑，最好的解决方案是使用用引号括起来的字符串值，例如 `{{ “{{” }}` 和 `{{ “}}” }}`

For example:  例如：

```
{{ "{{" }} and {{ "}}" }} are special SK sequences.
```

will render to:  将渲染为：

```
{{ and }} are special SK sequences.
```



## Values that include quotes, and escaping 包含引号和转义的值

Values can be enclosed using **single quotes** and **double quotes**.
可以使用**单引号**和**双引号**括住值。

To avoid the need for special syntax, when working with a value that contains *single quotes*, we recommend wrapping the value with *double quotes*. Similarly, when using a value that contains *double quotes*, wrap the value with *single quotes*.
为了避免需要特殊语法，当使用包含 *单引号，* 我们建议用*双引号*括住值。同样，当使用包含*双引号*的值时，请用*单引号*括住该值。

For example:  例如：

txtCopy  复制

```txt
...text... {{ functionName "one 'quoted' word" }} ...text...
...text... {{ functionName 'one "quoted" word' }} ...text...
```

For those cases where the value contains both single and double quotes, you will need *escaping*, using the special **«\»** symbol.
对于值同时包含单引号和双引号的情况，您需要使用特殊的 **«\»** 符号进行*转义* 。

When using double quotes around a value, use **«\"»** to include a double quote symbol inside the value:
在值周围使用双引号时，请使用 **«\“»** 在值内包含双引号符号：

```
... {{ "quotes' \"escaping\" example" }} ...
```

and similarly, when using single quotes, use **«\'»** to include a single quote inside the value:
同样，当使用单引号时，使用 **«\'»** 在值中包含单引号：

```
... {{ 'quotes\' "escaping" example' }} ...
```

Both are rendered to:
两者都被渲染为：

```
... quotes' "escaping" example ...
```

Note that for consistency, the sequences **«\'»** and **«\"»** do always render to **«'»** and **«"»**, even when escaping might not be required.
请注意，为了保持一致性，序列 **«\'»** 和 **«\“»** 总是渲染为 **«'»** 和 **«”»**，即使可能不需要转义。

For instance:  例如：

```
... {{ 'no need to \"escape" ' }} ...
```

is equivalent to:  相当于：

```
... {{ 'no need to "escape" ' }} ...
```

and both render to:
并且两者都渲染为：

```
... no need to "escape" ...
```

In case you may need to render a backslash in front of a quote, since **«\»** is a special char, you will need to escape it too, and use the special sequences **«\\\'»** and **«\\\"»**.
如果您可能需要在引号前面呈现反斜杠，因为 **«\»** 是一个特殊的字符，你也需要转义它，并使用特殊的序列 **«\\\'»** 和 **«\\\“»**。

For example:  例如：

```
{{ 'two special chars \\\' here' }}
```

is rendered to:  被渲染为：

```
two special chars \' here
```

Similarly to single and double quotes, the symbol **«\»** doesn't always need to be escaped. However, for consistency, it can be escaped even when not required.
与单引号和双引号类似，符号 **«\»** 并不总是需要转义。但是，为了保持一致性，即使不需要，也可以转义它。

For instance:  例如：

```
... {{ 'c:\\documents\\ai' }} ...
```

is equivalent to:  相当于：

```
... {{ 'c:\documents\ai' }} ...
```

and both are rendered to:
并且两者都呈现为：

```
... c:\documents\ai ...
```

Lastly, backslashes have a special meaning only when used in front of **«'»**, **«"»** and **«\»**.
最后，反斜杠只有在前面使用时才有特殊意义 **«'»**、**«“»** 和 **«\»**。

In all other cases, the backslash character has no impact and is rendered as is. For example:
在所有其他情况下，反斜杠字符没有影响，而是按原样呈现。例如：

```
{{ "nothing special about these sequences: \0 \n \t \r \foo" }}
```

is rendered to:  被渲染为：

```
nothing special about these sequences: \0 \n \t \r \foo
```



## Next steps  后续步骤

Semantic Kernel supports other popular template formats in addition to it's own built-in format. In the next sections we will look at to additional formats, [Handlebars](https://handlebarsjs.com/) and [Liquid](https://liquidjs.com/) templates.
Semantic Kernel除了自己的内置格式外，还支持其他流行的模板格式。在接下来的部分中，我们将了解其他格式、[Handlebars](https://handlebarsjs.com/) 和 [Liquid](https://liquidjs.com/) 模板。

  