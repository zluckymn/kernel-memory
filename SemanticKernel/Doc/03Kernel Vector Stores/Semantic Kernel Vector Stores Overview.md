# Generating embeddings for Semantic Kernel Vector Store connectors 为Semantic Kernel向量存储连接器生成嵌入

- 05/01/2025



Semantic Kernel Vector Store connectors support multiple ways of generating embeddings. Embeddings can be generated by the developer and passed as part of a record when using a `VectorStoreCollection` or can be generated internally to the `VectorStoreCollection`.
Semantic Kernel向量存储连接器支持多种生成嵌入的方式。嵌入可以由开发人员生成，并在使用 `VectorStoreCollection` 时作为记录的一部分传递，也可以在内部生成到 `VectorStoreCollection`。



## Letting the Vector Store generate embeddings 让向量存储生成嵌入

You can configure an embedding generator on your vector store, allowing embeddings to be automatically generated during both upsert and search operations, eliminating the need for manual preprocessing.
您可以在向量存储上配置嵌入生成器，允许在更新插入和搜索作期间自动生成嵌入，无需手动预处理。

To enable generating vectors automatically on upsert, the vector property on your data model is defined as the source type, e.g. string but still decorated with a `VectorStoreVectorPropertyAttribute`.
为了在更新插入时自动生成向量，数据模型上的向量属性被定义为源类型，例如字符串，但仍用 `VectorStoreVectorPropertyAttribute` .

C#Copy  复制

```csharp
    [VectorStoreVector(1536)]
    public string Embedding { get; set; }
```

Before upsert, the `Embedding` property should contain the string from which a vector should be generated. The type of the vector stored in the database (e.g. float32, float16, etc.) will be derived from the configured embedding generator.
在更新插入之前，`Embedding` 属性应包含应从中生成向量的字符串。存储在数据库中的向量类型（例如 float32、float16 等）将从配置的嵌入生成器派生。

 Important  重要

These vector properties do not support retrieving either the generated vector or the original text that the vector was generated from. They also do not store the original text. If the original text needs to be stored, a separate Data property should be added to store it.
这些向量属性不支持检索生成的向量或生成向量的原始文本。它们也不存储原始文本。如果需要存储原始文本，则应添加单独的 Data 属性来存储它。

Embedding generators implementing the `Microsoft.Extensions.AI` abstractions are supported and can be configured at various levels:
支持实现 `Microsoft.Extensions.AI` 抽象的嵌入生成器，并且可以在各种级别进行配置：

1. **On the Vector Store**: You can set a default embedding generator for the entire vector store. This generator will be used for all collections and properties unless overridden.
   **在矢量存储上** ：您可以为整个矢量存储设置默认嵌入生成器。除非被覆盖，否则此生成器将用于所有集合和属性。

   C#Copy  复制

   ```csharp
   using Microsoft.Extensions.AI;
   using Microsoft.SemanticKernel.Connectors.Qdrant;
   using OpenAI;
   using Qdrant.Client;
   
   var embeddingGenerator = new OpenAIClient("your key")
       .GetEmbeddingClient("your chosen model")
       .AsIEmbeddingGenerator();
   
   var vectorStore = new QdrantVectorStore(
       new QdrantClient("localhost"),
       ownsClient: true,
       new QdrantVectorStoreOptions
       {
            EmbeddingGenerator = embeddingGenerator
       });
   ```

2. **On a Collection**: You can configure an embedding generator for a specific collection, overriding the store-level generator.
   **在集合上** ：您可以为特定集合配置嵌入生成器，覆盖存储级生成器。

   C#Copy  复制

   ```csharp
   using Microsoft.Extensions.AI;
   using Microsoft.SemanticKernel.Connectors.Qdrant;
   using OpenAI;
   using Qdrant.Client;
   
   var embeddingGenerator = new OpenAIClient("your key")
       .GetEmbeddingClient("your chosen model")
       .AsIEmbeddingGenerator();
   
   var collectionOptions = new QdrantCollectionOptions
   {
       EmbeddingGenerator = embeddingGenerator
   };
   var collection = new QdrantCollection<ulong, MyRecord>(
       new QdrantClient("localhost"),
       "myCollection",
       ownsClient: true,
       collectionOptions);
   ```

3. **On a Record Definition**: When defining properties programmatically using `VectorStoreCollectionDefinition`, you can specify an embedding generator for all properties.
   **在记录定义上** ：使用 `VectorStoreCollectionDefinition` 以编程方式定义属性时，可以为所有属性指定嵌入生成器。

   C#Copy  复制

   ```csharp
   using Microsoft.Extensions.AI;
   using Microsoft.Extensions.VectorData;
   using Microsoft.SemanticKernel.Connectors.Qdrant;
   using OpenAI;
   using Qdrant.Client;
   
   var embeddingGenerator = new OpenAIClient("your key")
       .GetEmbeddingClient("your chosen model")
       .AsIEmbeddingGenerator();
   
   var definition = new VectorStoreCollectionDefinition
   {
       EmbeddingGenerator = embeddingGenerator,
       Properties = new List<VectorStoreProperty>
       {
           new VectorStoreKeyProperty("Key", typeof(ulong)),
           new VectorStoreVectorProperty("DescriptionEmbedding", typeof(string), dimensions: 1536)
       }
   };
   
   var collectionOptions = new QdrantCollectionOptions
   {
       Definition = definition
   };
   var collection = new QdrantCollection<ulong, MyRecord>(
       new QdrantClient("localhost"),
       "myCollection",
       ownsClient: true,
       collectionOptions);
   ```

4. **On a Vector Property Definition**: When defining properties programmatically, you can set an embedding generator directly on the property.
   **在向量属性定义上** ：以编程方式定义属性时，可以直接在属性上设置嵌入生成器。

   C#Copy  复制

   ```csharp
   using Microsoft.Extensions.AI;
   using Microsoft.Extensions.VectorData;
   using OpenAI;
   
   var embeddingGenerator = new OpenAIClient("your key")
       .GetEmbeddingClient("your chosen model")
       .AsIEmbeddingGenerator();
   
   var vectorProperty = new VectorStoreVectorProperty("DescriptionEmbedding", typeof(string), dimensions: 1536)
   {
        EmbeddingGenerator = embeddingGenerator
   };
   ```



### Example Usage  用法示例

The following example demonstrates how to use the embedding generator to automatically generate vectors during both upsert and search operations. This approach simplifies workflows by eliminating the need to precompute embeddings manually.
以下示例演示了如何使用嵌入生成器在更新插入和搜索作期间自动生成向量。这种方法无需手动预先计算嵌入，从而简化了工作流程。

C#Copy  复制

```csharp
// The data model
internal class FinanceInfo
{
    [VectorStoreKey]
    public string Key { get; set; } = string.Empty;

    [VectorStoreData]
    public string Text { get; set; } = string.Empty;

    // Note that the vector property is typed as a string, and
    // its value is derived from the Text property. The string
    // value will however be converted to a vector on upsert and
    // stored in the database as a vector.
    [VectorStoreVector(1536)]
    public string Embedding => this.Text;
}

// Create an OpenAI embedding generator.
var embeddingGenerator = new OpenAIClient("your key")
    .GetEmbeddingClient("your chosen model")
    .AsIEmbeddingGenerator();

// Use the embedding generator with the vector store.
var vectorStore = new InMemoryVectorStore(new() { EmbeddingGenerator = embeddingGenerator });
var collection = vectorStore.GetCollection<string, FinanceInfo>("finances");
await collection.EnsureCollectionExistsAsync();

// Create some test data.
string[] budgetInfo =
{
    "The budget for 2020 is EUR 100 000",
    "The budget for 2021 is EUR 120 000",
    "The budget for 2022 is EUR 150 000",
    "The budget for 2023 is EUR 200 000",
    "The budget for 2024 is EUR 364 000"
};

// Embeddings are generated automatically on upsert.
var records = budgetInfo.Select((input, index) => new FinanceInfo { Key = index.ToString(), Text = input });
await collection.UpsertAsync(records);

// Embeddings for the search is automatically generated on search.
var searchResult = collection.SearchAsync(
    "What is my budget for 2024?",
    top: 1);

// Output the matching result.
await foreach (var result in searchResult)
{
    Console.WriteLine($"Key: {result.Record.Key}, Text: {result.Record.Text}");
}
```



## Generating embeddings yourself 自行生成嵌入



### Constructing an embedding generator 构建嵌入生成器

See [Embedding Generation](https://learn.microsoft.com/en-us/semantic-kernel/concepts/ai-services/embedding-generation/) for examples on how to construct Semantic Kernel `ITextEmbeddingGenerationService` instances.
有关如何构造Semantic Kernel `ITextEmbeddingGenerationService` 实例的示例，请参阅嵌入[生成 ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/ai-services/embedding-generation/)。

See [Microsoft.Extensions.AI.Abstractions](https://www.nuget.org/packages/Microsoft.Extensions.AI.Abstractions) for information on how to construct `Microsoft.Extensions.AI` embedding generation services.
有关如何构造 `Microsoft.Extensions.AI` 嵌入生成服务的信息，请参阅 [Microsoft.Extensions.AI.Abstractions](https://www.nuget.org/packages/Microsoft.Extensions.AI.Abstractions)。



### Generating embeddings on upsert with Semantic Kernel `ITextEmbeddingGenerationService` 使用Semantic Kernel `ITextEmbeddingGenerationService` 在更新插入时生成嵌入

C#Copy  复制

```csharp
public async Task GenerateEmbeddingsAndUpsertAsync(
    ITextEmbeddingGenerationService textEmbeddingGenerationService,
    VectorStoreCollection<ulong, Hotel> collection)
{
    // Upsert a record.
    string descriptionText = "A place where everyone can be happy.";
    ulong hotelId = 1;

    // Generate the embedding.
    ReadOnlyMemory<float> embedding =
        await textEmbeddingGenerationService.GenerateEmbeddingAsync(descriptionText);

    // Create a record and upsert with the already generated embedding.
    await collection.UpsertAsync(new Hotel
    {
        HotelId = hotelId,
        HotelName = "Hotel Happy",
        Description = descriptionText,
        DescriptionEmbedding = embedding,
        Tags = new[] { "luxury", "pool" }
    });
}
```



### Generating embeddings on search with Semantic Kernel `ITextEmbeddingGenerationService` 使用Semantic Kernel `ITextEmbeddingGenerationService` 在搜索时生成嵌入

C#Copy  复制

```csharp
public async Task GenerateEmbeddingsAndSearchAsync(
    ITextEmbeddingGenerationService textEmbeddingGenerationService,
    VectorStoreCollection<ulong, Hotel> collection)
{
    // Upsert a record.
    string descriptionText = "Find me a hotel with happiness in mind.";

    // Generate the embedding.
    ReadOnlyMemory<float> searchEmbedding =
        await textEmbeddingGenerationService.GenerateEmbeddingAsync(descriptionText);

    // Search using the already generated embedding.
    IAsyncEnumerable<VectorSearchResult<Hotel>> searchResult = collection.SearchAsync(searchEmbedding, top: 1);
    List<VectorSearchResult<Hotel>> resultItems = await searchResult.ToListAsync();

    // Print the first search result.
    Console.WriteLine("Score for first result: " + resultItems.FirstOrDefault()?.Score);
    Console.WriteLine("Hotel description for first result: " + resultItems.FirstOrDefault()?.Record.Description);
}
```

 Tip  提示

For more information on generating embeddings, refer to [Embedding generation in Semantic Kernel](https://learn.microsoft.com/en-us/semantic-kernel/concepts/ai-services/embedding-generation/).
有关生成嵌入的更多信息，请参阅语[义内核中的嵌入生成 ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/ai-services/embedding-generation/)。



## Embedding dimensions  嵌入尺寸

Vector databases typically require you to specify the number of dimensions that each vector has when creating the collection. Different embedding models typically support generating vectors with various dimension sizes. E.g., OpenAI `text-embedding-ada-002` generates vectors with 1536 dimensions. Some models also allow a developer to choose the number of dimensions they want in the output vector. For example, Google `text-embedding-004` produces vectors with 768 dimensions by default, but allows a developer to choose any number of dimensions between 1 and 768.
矢量数据库通常要求您在创建集合时指定每个矢量具有的维度数。不同的嵌入模型通常支持生成具有不同维度大小的向量。例如，OpenAI `text-embedding-ada-002` 生成具有 1536 维的向量。某些模型还允许开发人员在 输出向量。例如，Google `text-embedding-004` 默认生成维度为 768 的向量，但允许开发人员选择 1 到 768 之间的任意数量的维度。

It is important to ensure that the vectors generated by the embedding model have the same number of dimensions as the matching vector in the database.
重要的是要确保嵌入模型生成的向量与数据库中的匹配向量具有相同的维数。

If creating a collection using the Semantic Kernel Vector Store abstractions, you need to specify the number of dimensions required for each vector property either via annotations or via the record definition. Here are examples of both setting the number of dimensions to 1536.
如果使用Semantic Kernel向量存储抽象创建集合，则需要通过注释或记录定义指定每个向量属性所需的维度数。下面是将维度数设置为 1536 的示例。

C#Copy  复制

```csharp
[VectorStoreVector(Dimensions: 1536)]
public ReadOnlyMemory<float>? DescriptionEmbedding { get; set; }
```

C#Copy  复制

```csharp
new VectorStoreVectorProperty("DescriptionEmbedding", typeof(float), dimensions: 1536);
```

 Tip  提示

For more information on how to annotate your data model, refer to [defining your data model](https://learn.microsoft.com/en-us/semantic-kernel/concepts/vector-store-connectors/defining-your-data-model).
有关如何注释数据模型的更多信息，请参阅[定义数据模型 ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/vector-store-connectors/defining-your-data-model)。

 Tip  提示

For more information on creating a record definition, refer to [defining your schema with a record definition](https://learn.microsoft.com/en-us/semantic-kernel/concepts/vector-store-connectors/schema-with-record-definition).
有关创建记录定义的更多信息，请参阅使用[记录定义定义](https://learn.microsoft.com/en-us/semantic-kernel/concepts/vector-store-connectors/schema-with-record-definition)架构。