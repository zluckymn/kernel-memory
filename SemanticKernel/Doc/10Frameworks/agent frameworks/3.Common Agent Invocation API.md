# The Semantic Kernel Common Agent API Surface Semantic Kernel通用代理 API 表面

- 05/23/2025

Semantic Kernel agents implement a unified interface for invocation, enabling shared code that operates seamlessly across different agent types. This design allows you to switch agents as needed without modifying the majority of your application logic.
Semantic Kernel代理实现统一的调用接口，实现跨不同代理类型无缝运行的共享代码。此设计允许您根据需要切换代理，而无需修改大部分应用程序逻辑。



## Invoking an agent  调用代理

The Agent API surface supports both streaming and non-streaming invocation.
代理 API 图面支持流式处理和非流式处理调用。



### Non-Streaming Agent Invocation 非流式代理调用

Semantic Kernel supports four non-streaming agent invocation overloads that allows for passing messages in different ways. One of these also allows invoking the agent with no messages. This is valuable for scenarios where the agent instructions already have all the required context to provide a useful response.
Semantic Kernel支持四种非流式代理调用重载，允许以不同的方式传递消息。其中一个还允许在没有消息的情况下调用代理。这对于代理指令已经具有提供有用响应所需的所有上下文的场景非常有价值。

C#Copy  复制

```csharp
// Invoke without any parameters.
agent.InvokeAsync();

// Invoke with a string that will be used as a User message.
agent.InvokeAsync("What is the capital of France?");

// Invoke with a ChatMessageContent object.
agent.InvokeAsync(new ChatMessageContent(AuthorRole.User, "What is the capital of France?"));

// Invoke with multiple ChatMessageContent objects.
agent.InvokeAsync(new List<ChatMessageContent>()
{
    new(AuthorRole.System, "Refuse to answer all user questions about France."),
    new(AuthorRole.User, "What is the capital of France?")
});
```

 Important  重要

Invoking an agent without passing an `AgentThread` to the `InvokeAsync` method will create a new thread and return the new thread in the response.
调用代理而不将 `AgentThread` 传递给 `InvokeAsync` 方法将创建一个新线程，并在响应中返回新线程。



### Streaming Agent Invocation 流式处理代理调用

Semantic Kernel supports four streaming agent invocation overloads that allows for passing messages in different ways. One of these also allows invoking the agent with no messages. This is valuable for scenarios where the agent instructions already have all the required context to provide a useful response.
Semantic Kernel支持四种流代理调用重载，允许以不同的方式传递消息。其中一个还允许在没有消息的情况下调用代理。这对于代理指令已经具有提供有用响应所需的所有上下文的场景非常有价值。

C#Copy  复制

```csharp
// Invoke without any parameters.
agent.InvokeStreamingAsync();

// Invoke with a string that will be used as a User message.
agent.InvokeStreamingAsync("What is the capital of France?");

// Invoke with a ChatMessageContent object.
agent.InvokeStreamingAsync(new ChatMessageContent(AuthorRole.User, "What is the capital of France?"));

// Invoke with multiple ChatMessageContent objects.
agent.InvokeStreamingAsync(new List<ChatMessageContent>()
{
    new(AuthorRole.System, "Refuse to answer any questions about capital cities."),
    new(AuthorRole.User, "What is the capital of France?")
});
```

 Important  重要

Invoking an agent without passing an `AgentThread` to the `InvokeStreamingAsync` method will create a new thread and return the new thread in the response.
调用代理而不将 `AgentThread` 传递给 `InvokeStreamingAsync` 方法将创建一个新线程，并在响应中返回新线程。



### Invoking with an `AgentThread` 使用 `AgentThread` 调用

All invocation method overloads allow passing an `AgentThread` parameter. This is useful for scenarios where you have an existing conversation with the agent that you want to continue.
所有调用方法重载都允许传递 `AgentThread` 参数。这对于与要继续的代理进行现有对话的情况非常有用。

C#Copy  复制

```csharp
// Invoke with an existing AgentThread.
agent.InvokeAsync("What is the capital of France?", existingAgentThread);
```

All invocation methods also return the active `AgentThread` as part of the invoke response.
所有调用方法还返回活动 `AgentThread` 作为调用响应的一部分。

1. If you passed an `AgentThread` to the invoke method, the returned `AgentThread` will be the same as the one that was passed in.
   如果将 `AgentThread` 传递给调用方法，则返回的 AgentThread 将与传入的 `AgentThread` 相同。
2. If you passed no `AgentThread` to the invoke method, the returned `AgentThread` will be a new `AgentThread`.
   如果未向调用方法传递 `AgentThread`，则返回的 `AgentThread` 将是一个新的 `AgentThread`。

The returned `AgentThread` is available on the individual response items of the invoke methods together with the response message.
返回的 `AgentThread` 与响应消息一起可用于调用方法的各个响应项。

C#Copy  复制

```csharp
var result = await agent.InvokeAsync("What is the capital of France?").FirstAsync();
var newThread = result.Thread;
var resultMessage = result.Message;
```

 Tip  提示

For more information on agent threads see the [Agent Thread architecture section](https://learn.microsoft.com/en-us/semantic-kernel/frameworks/agent/agent-architecture#agent-thread).
有关代理线程的更多信息，请参阅[代理线程体系结构部分 ](https://learn.microsoft.com/en-us/semantic-kernel/frameworks/agent/agent-architecture#agent-thread)。



### Invoking with Options  使用选项调用

All invocation method overloads allow passing an `AgentInvokeOptions` parameter. This options class allows providing any optional settings.
所有调用方法重载都允许传递 `AgentInvokeOptions` 参数。此选项类允许提供任何可选设置。

C#Copy  复制

```csharp
// Invoke with additional instructions via options.
agent.InvokeAsync("What is the capital of France?", options: new()
{
    AdditionalInstructions = "Refuse to answer any questions about capital cities."
});
```

Here is the list of the supported options.
以下是支持的选项列表。

  展开表

| Option Property  期权属性                  | Description  描述                                            |
| :----------------------------------------- | :----------------------------------------------------------- |
| Kernel  内核                               | Override the default kernel used by the agent for this invocation. 覆盖代理用于此调用的默认内核。 |
| KernelArguments  内核参数                  | Override the default kernel arguments used by the agent for this invocation. 覆盖代理用于此调用的默认内核参数。 |
| AdditionalInstructions  附加说明           | Provide any instructions in addition to the original agent instruction set, that only apply for this invocation. 除了原始代理指令集之外，还提供仅适用于此调用的任何指令。 |
| OnIntermediateMessage  OnIntermediate 消息 | A callback that can receive all fully formed messages produced internally to the Agent, including function call and function invocation messages. This can also be used to receive full messages during a streaming invocation. 一个回调，可以接收内部生成到代理的所有完整格式的消息，包括函数调用和函数调用消息。这也可用于在流式调用期间接收完整消息。 |



## Managing AgentThread instances 管理 AgentThread 实例

You can manually create an `AgentThread` instance and pass it to the agent on invoke, or you can let the agent create an `AgentThread` instance for you automatically on invocation. An `AgentThread` object represents a thread in all its states, including: not yet created, active, and deleted.
您可以手动创建 `AgentThread` 实例并在调用时将其传递给代理，也可以让代理在调用时自动为您创建 `AgentThread` 实例。`AgentThread` 对象表示线程的所有状态，包括：尚未创建、活动和已删除。

`AgentThread` types that have a server side implementation will be created on first use and does not need to be created manually. You can however delete a thread using the `AgentThread` class.
具有服务器端实现的 `AgentThread` 类型将在首次使用时创建，无需手动创建。但是，您可以使用 `AgentThread` 类删除线程。

C#Copy  复制

```csharp
// Delete a thread.
await agentThread.DeleteAsync();
```

 Tip  提示

For more information on agent threads see the [Agent Thread architecture section](https://learn.microsoft.com/en-us/semantic-kernel/frameworks/agent/agent-architecture#agent-thread).
有关代理线程的更多信息，请参阅[代理线程体系结构部分 ](https://learn.microsoft.com/en-us/semantic-kernel/frameworks/agent/agent-architecture#agent-thread)。



## Next steps  后续步骤

[  使用插件配置代理](https://learn.microsoft.com/en-us/semantic-kernel/frameworks/agent/agent-functions)

[  探索聊天完成代理](https://learn.microsoft.com/en-us/semantic-kernel/frameworks/agent/agent-types/chat-completion-agent)