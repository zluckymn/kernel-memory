# Contextual Function Selection with Agents 使用代理进行上下文函数选择

- 07/01/2025

This feature is in the experimental stage. Features at this stage are under active development and may change significantly before advancing to the preview or release candidate stage.
此功能处于实验阶段。此阶段的功能正在积极开发中，在进入预览版或候选版本阶段之前可能会发生重大变化。



## Overview  概述

Contextual Function Selection is an advanced capability in the Semantic Kernel Agent Framework that enables agents to dynamically select and advertise only the most relevant functions based on the current conversation context. Instead of exposing all available functions to the AI model, this feature uses Retrieval-Augmented Generation (RAG) to filter and present only those functions most pertinent to the user’s request.
上下文函数选择是Semantic Kernel代理框架中的一项高级功能，它使代理能够根据当前对话上下文动态选择和通告最相关的功能。此功能不会向 AI 模型公开所有可用函数，而是使用检索增强生成 （RAG） 来过滤并仅显示与用户请求最相关的函数。

This approach addresses the challenge of function selection when dealing with a large number of available functions, where AI models may otherwise struggle to choose the appropriate function, leading to confusion and suboptimal performance.
这种方法解决了在处理大量可用功能时功能选择的挑战，否则人工智能模型可能难以选择合适的功能，从而导致混乱和性能不佳。

 Warning  警告

When using the `ContextualFunctionProvider`, the `UseImmutableKernel` setting on the agent has to be set to `true` as the feature requires cloning the kernel when invoking the agent. Note that setting `UseImmutableKernel` to `true` will mean that any kernel data modifications done during the agent invocation by e.g. plugins, will not be retained after the invocation completes.
使用 `ContextualFunctionProvider` 时，代理上的 `UseImmutableKernel` 设置必须设置为 `true`，因为该功能在调用代理时需要克隆内核。请注意，将 `UseImmutableKernel` 设置为 `true` 将意味着在调用完成后，将不会保留在代理调用期间通过插件等方式进行的任何内核数据修改。



## How Contextual Function Selection Works 上下文函数选择的工作原理

When an agent is configured with contextual function selection, it leverages a vector store and an embedding generator to semantically match the current conversation context (including previous messages and user input) with the descriptions and names of available functions. The most relevant functions, up to the specified limit, are then advertised to the AI model for invocation.
当代理配置了上下文函数选择时，它利用向量存储和嵌入生成器在语义上将当前对话上下文（包括以前的消息和用户输入）与可用函数的描述和名称进行匹配。然后，最相关的函数（达到指定限制）将通告给 AI 模型进行调用。

This mechanism is especially useful for agents that have access to a broad set of plugins or tools, ensuring that only contextually appropriate actions are considered at each step.
此机制对于可以访问大量插件或工具的代理特别有用，确保在每个步骤中仅考虑上下文适当的作。



## Usage Example  使用示例

The following example demonstrates how an agent can be configured to use contextual function selection. The agent is set up to summarize customer reviews, but only the most relevant functions are advertised to the AI model for each invocation. The `GetAvailableFunctions` method intentionally includes both relevant and irrelevant functions to highlight the benefits of contextual selection.
以下示例演示了如何将代理配置为使用上下文函数选择。代理设置为汇总客户评论，但每次调用时，只有最相关的功能才会向 AI 模型通告。`GetAvailableFunctions` 方法有意包含相关和不相关的函数，以突出上下文选择的好处。

C#Copy  复制

```csharp
// Create an embedding generator for function vectorization
var embeddingGenerator = new AzureOpenAIClient(new Uri("<endpoint>"), new ApiKeyCredential("<api-key>"))
    .GetEmbeddingClient("<deployment-name>")
    .AsIEmbeddingGenerator();

// Create kernel and register AzureOpenAI chat completion service
var kernel = Kernel.CreateBuilder()
    .AddAzureOpenAIChatCompletion("<deployment-name>", "<endpoint>", "<api-key>");
    .Build();

// Create a chat completion agent
ChatCompletionAgent agent = new()
{
    Name = "ReviewGuru",
    Instructions = "You are a friendly assistant that summarizes key points and sentiments from customer reviews. For each response, list available functions.",
    Kernel = kernel,
    Arguments = new(new PromptExecutionSettings { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto(options: new FunctionChoiceBehaviorOptions { RetainArgumentTypes = true }) }),
    // This setting must be set to true when using the ContextualFunctionProvider
    UseImmutableKernel = true
};

// Create the agent thread and register the contextual function provider
ChatHistoryAgentThread agentThread = new();

agentThread.AIContextProviders.Add(
    new ContextualFunctionProvider(
        vectorStore: new InMemoryVectorStore(new InMemoryVectorStoreOptions() { EmbeddingGenerator = embeddingGenerator }),
        vectorDimensions: 1536,
        functions: AvailableFunctions(),
        maxNumberOfFunctions: 3, // Only the top 3 relevant functions are advertised
        loggerFactory: LoggerFactory
    )
);


// Invoke the agent
ChatMessageContent message = await agent.InvokeAsync("Get and summarize customer review.", agentThread).FirstAsync();
Console.WriteLine(message.Content);

// Output
/*
    Customer Reviews:
    -----------------
    1. John D. - ★★★★★
       Comment: Great product and fast shipping!
       Date: 2023-10-01

    Summary:
    --------
    The reviews indicate high customer satisfaction,
    highlighting product quality and shipping speed.

    Available functions:
    --------------------
    - Tools-GetCustomerReviews
    - Tools-Summarize
    - Tools-CollectSentiments
*/

IReadOnlyList<AIFunction> GetAvailableFunctions()
{
    // Only a few functions are directly related to the prompt; the majority are unrelated to demonstrate the benefits of contextual filtering.
    return new List<AIFunction>
    {
        // Relevant functions
        AIFunctionFactory.Create(() => "[ { 'reviewer': 'John D.', 'date': '2023-10-01', 'rating': 5, 'comment': 'Great product and fast shipping!' } ]", "GetCustomerReviews"),
        AIFunctionFactory.Create((string text) => "Summary generated based on input data: key points include customer satisfaction.", "Summarize"),
        AIFunctionFactory.Create((string text) => "The collected sentiment is mostly positive.", "CollectSentiments"),

        // Irrelevant functions
        AIFunctionFactory.Create(() => "Current weather is sunny.", "GetWeather"),
        AIFunctionFactory.Create(() => "Email sent.", "SendEmail"),
        AIFunctionFactory.Create(() => "The current stock price is $123.45.", "GetStockPrice"),
        AIFunctionFactory.Create(() => "The time is 12:00 PM.", "GetCurrentTime")
    };
}
```



## Vector Store  矢量存储

The provider is primarily designed to work with in-memory vector stores, which offer simplicity. However, if other types of vector stores are used, it is important to note that the responsibility for handling data synchronization and consistency falls on the hosting application.
该提供程序主要设计用于使用内存中向量存储，这提供了简单性。但是，如果使用其他类型的向量存储，请务必注意，处理数据同步和一致性的责任落在托管应用程序身上。

Synchronization is necessary whenever the list of functions changes or when the source of function embeddings is modified. For example, if an agent initially has three functions (f1, f2, f3) that are vectorized and stored in a cloud vector store, and later f3 is removed from the agent's list of functions, the vector store must be updated to reflect only the current functions the agent has (f1 and f2). Failing to update the vector store may result in irrelevant functions being returned as results. Similarly, if the data used for vectorization such as function names, descriptions, etc. changes, the vector store should be purged and repopulated with new embeddings based on the updated information.
每当函数列表发生更改或修改函数嵌入源时，都需要同步。例如，如果代理最初具有三个函数（f1、f2、f3），这些函数被矢量化并存储在云矢量存储中，后来 f3 从代理的函数列表中删除，则必须更新矢量存储以仅反映代理具有的当前函数（f1 和 f2）。未能更新向量存储可能会导致不相关的函数作为结果返回。同样，如果用于矢量化的数据（如函数名称、描述等）发生变化，则应清除矢量存储，并根据更新的信息重新填充新的嵌入。

Managing data synchronization in external or distributed vector stores can be complex and prone to errors, especially in distributed applications where different services or instances may operate independently and require consistent access to the same data. In contrast, using an in-memory store simplifies this process: when the function list or vectorization source changes, the in-memory store can be easily recreated with the new set of functions and their embeddings, ensuring consistency with minimal effort.
在外部或分布式向量存储中管理数据同步可能很复杂且容易出错，尤其是在分布式应用程序中，其中不同的服务或实例可能独立运行，并且需要对相同数据进行一致的访问。相比之下，使用内存中存储可以简化此过程：当函数列表或矢量化源发生更改时，可以使用新的函数集及其嵌入轻松重新创建内存中存储，从而以最小的努力确保一致性。



## Specifying Functions  指定函数

The contextual function provider must be supplied with a list of functions from which it can select the most relevant ones based on the current context. This is accomplished by providing a list of functions to the `functions` parameter of the `ContextualFunctionProvider` constructor.
必须为上下文函数提供程序提供函数列表，它可以根据当前上下文从中选择最相关的函数。这是通过向 `ContextualFunctionProvider` 构造函数的 `functions` 参数提供函数列表来实现的。

In addition to the functions, you must also specify the maximum number of relevant functions to return using the `maxNumberOfFunctions` parameter. This parameter determines how many functions the provider will consider when selecting the most relevant ones for the current context. The specified number is not meant to be precise; rather, it serves as an upper limit that depends on the specific scenario.
除了函数之外，还必须使用 `maxNumberOfFunctions` 参数指定要返回的相关函数的最大数量。此参数确定提供程序在选择与当前上下文最相关的函数时将考虑多少函数。指定的数字并不意味着精确;相反，它充当取决于具体场景的上限。

Setting this value too low may prevent the agent from accessing all the necessary functions for a scenario, potentially leading to the scenario failure. Conversely, setting it too high may overwhelm the agent with too many functions, which can result in hallucinations, excessive input token consumption, and suboptimal performance.
将此值设置得太低可能会阻止代理访问方案的所有必要功能，从而可能导致方案失败。相反，设置得太高可能会让代理因过多的功能而不堪重负，从而导致幻觉、输入令牌消耗过多和性能不佳。

C#Copy  复制

```csharp
// Create the provider with a list of functions and a maximum number of functions to return
ContextualFunctionProvider provider = new (
    vectorStore: new InMemoryVectorStore(new InMemoryVectorStoreOptions { EmbeddingGenerator = embeddingGenerator }),
    vectorDimensions: 1536,
    functions: [AIFunctionFactory.Create((string text) => $"Echo: {text}", "Echo"), <other functions>]
    maxNumberOfFunctions: 3 // Only the top 3 relevant functions are advertised
);
```



## Contextual Function Provider Options 上下文函数提供程序选项

The provider can be configured using the `ContextualFunctionProviderOptions` class, which allows you to customize various aspects of how the provider operates:
可以使用 `ContextualFunctionProviderOptions` 类配置提供程序，它允许您自定义提供程序作方式的各个方面：

C#Copy  复制

```csharp
// Create options for the contextual function provider
ContextualFunctionProviderOptions options = new ()
{
    ...
};

// Create the provider with options
ContextualFunctionProvider provider = new (
    ...
    options: options // Pass the options
);
```



### Context Size  上下文大小

The context size determines how many recent messages from previous agent invocations are included when forming the context for a new invocation. The provider collects all messages from previous invocations, up to the specified number, and prepends them to the new messages to form the context.
上下文大小确定在形成新调用的上下文时，包括来自先前代理调用的最近消息数。提供程序从以前的调用中收集所有消息（最多指定数量），并将它们附加到新消息之前以形成上下文。

Using recent messages together with new messages is especially useful for tasks that require information from earlier steps in a conversation. For example, if an agent provisions a resource in one invocation and deploys it in the next, the deployment step can access details from the provisioning step to get provisioned resource information for the deployment.
将最近的消息与新消息一起使用对于需要对话中早期步骤的信息的任务特别有用。例如，如果代理在一次调用中预配资源，并在下一次调用中部署它，则部署步骤可以访问预配步骤中的详细信息，以获取部署的预配资源信息。

The default value for the number of recent messages in context is 2, but this can be configured as needed by specifying the `NumberOfRecentMessagesInContext` property in the `ContextualFunctionProviderOptions`:
上下文中最近消息数的默认值为 2，但可以根据需要通过在 ： `ContextualFunctionProviderOptions` 中指定 `NumberOfRecentMessagesInContext` 属性来配置 ：

C#Copy  复制

```csharp
ContextualFunctionProviderOptions options = new ()
{
    NumberOfRecentMessagesInContext = 1 // Only the last message will be included in the context
};
```



### Context Embedding Source Value 上下文嵌入源值

To perform contextual function selection, the provider needs to vectorize the current context so it can be compared with available functions in the vector store. By default, the provider creates this context embedding by concatenating all non-empty recent and new messages into a single string, which is then vectorized and used to search for relevant functions.
若要执行上下文函数选择，提供程序需要矢量化当前上下文，以便将其与矢量存储中的可用函数进行比较。默认情况下，提供程序通过将所有非空的最近消息和新消息连接成单个字符串来创建此上下文嵌入，然后对该字符串进行矢量化并用于搜索相关函数。

In some scenarios, you may want to customize this behavior to:
在某些情况下，您可能希望将此行为自定义为：

- Focus on specific message types (e.g., only user messages)
  关注特定消息类型（例如，仅用户消息）
- Exclude certain information from context
  从上下文中排除某些信息
- Preprocess or summarize the context before vectorization (e.g., apply prompt rewriting)
  在矢量化之前预处理或总结上下文（例如，应用提示重写）

To do this, you can assign a custom delegate to `ContextEmbeddingValueProvider`. This delegate receives the recent and new messages, and returns a string value to be used as a source for the context embedding:
为此，您可以将自定义委托分配给 `ContextEmbeddingValueProvider`。此委托接收最近消息和新消息，并返回一个字符串值，用作上下文嵌入的源：

C#Copy  复制

```csharp
ContextualFunctionProviderOptions options = new()
{
    ContextEmbeddingValueProvider = async (recentMessages, newMessages, cancellationToken) =>
    {
        // Example: Only include user messages in the embedding
        var allUserMessages = recentMessages.Concat(newMessages)
            .Where(m => m.Role == "user")
            .Select(m => m.Content)
            .Where(content => !string.IsNullOrWhiteSpace(content));
        return string.Join("\n", allUserMessages);
    }
};
```

Customizing the context embedding can improve the relevance of function selection, especially in complex or highly specialized agent scenarios.
自定义上下文嵌入可以提高函数选择的相关性，尤其是在复杂或高度专业化的代理场景中。



### Function Embedding Source Value 函数嵌入源值

The provider needs to vectorize each available function in order to compare it with the context and select the most relevant ones. By default, the provider creates a function embedding by concatenating the function's name and description into a single string, which is then vectorized and stored in the vector store.
提供程序需要矢量化每个可用函数，以便将其与上下文进行比较并选择最相关的函数。默认情况下，提供程序通过将函数的名称和描述连接成单个字符串来创建函数嵌入，然后将其矢量化并存储在矢量存储中。

You can customize this behavior using the `EmbeddingValueProvider` property of `ContextualFunctionProviderOptions`. This property allows you to specify a callback that receives the function and a cancellation token, and returns a string to be used as the source for the function embedding. This is useful if you want to:
您可以使用 的 `ContextualFunctionProviderOptions` `EmbeddingValueProvider` 属性自定义此行为。此属性允许您指定接收函数和取消令牌的回调，并返回一个字符串以用作函数嵌入的源。如果您想：

- Add additional function metadata to the embedding source
  将其他函数元数据添加到嵌入源
- Preprocess, filter, or reformat the function information before vectorization
  在矢量化之前对函数信息进行预处理、过滤或重新格式化

C#Copy  复制

```csharp
ContextualFunctionProviderOptions options = new()
{
    EmbeddingValueProvider = async (function, cancellationToken) =>
    {
        // Example: Use only the function name for embedding
        return function.Name;
    }
};
```

Customizing the function embedding source value can improve the accuracy of function selection, especially when your functions have rich, context-relevant metadata or when you want to focus the search on specific aspects of each function.
自定义函数嵌入源值可以提高函数选择的准确性，尤其是当函数具有丰富的上下文相关元数据或想要将搜索重点放在每个函数的特定方面时。