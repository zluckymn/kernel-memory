# Semantic Kernel Agent Orchestration Advanced Topics 语义内核代理编排高级主题

- 05/23/2025



 Important  重要

Agent Orchestration features in the Agent Framework are in the experimental stage. They are under active development and may change significantly before advancing to the preview or release candidate stage.
代理框架中的代理业务流程功能处于实验阶段。它们正在积极开发中，在进入预览版或候选版本阶段之前可能会发生重大变化。



## Runtime  运行

The runtime is the foundational component that manages the lifecycle, communication, and execution of agents and orchestrations. It acts as the message bus and execution environment for all actors (agents and orchestration-specific actors) in the system.
运行时是管理代理和业务流程的生命周期、通信和执行的基础组件。它充当系统中所有参与者（代理和特定于业务流程的参与者）的消息总线和执行环境。



### Role of the Runtime  运行时的角色

- **Message Routing:** The runtime is responsible for delivering messages between agents and orchestration actors, using a pub-sub or direct messaging model depending on the orchestration pattern.
  **消息路由：** 运行时负责在代理和业务流程参与者之间传递消息，根据业务流程模式使用发布-订阅或直接消息传递模型。
- **Actor Lifecycle Management:** It creates, registers, and manages the lifecycle of all actors involved in an orchestration, ensuring isolation and proper resource management.
  **参与者生命周期管理：** 它创建、注册和管理业务流程中涉及的所有参与者的生命周期，确保隔离和适当的资源管理。
- **Execution Context:** The runtime provides the execution context for orchestrations, allowing multiple orchestrations (and their invocations) to run independently and concurrently.
  **执行上下文：** 运行时为业务流程提供执行上下文，允许多个业务流程（及其调用）独立并发运行。



### Relationship Between Runtime and Orchestrations 运行时和业务流程之间的关系

Think of an orchestration as a graph that defines how agents interact with each other. The runtime is the engine that executes this graph, managing the flow of messages and the lifecycle of agents. Developers can execute this graph multiple times with different inputs on the same runtime instance, and the runtime will ensure that each execution is isolated and independent.
将业务流程视为定义代理如何相互交互的图表。运行时是执行此图的引擎，管理消息流和代理的生命周期。开发人员可以在同一运行时实例上使用不同的输入多次执行此图，运行时将确保每次执行都是隔离和独立的。



## Timeouts  超时

When an orchestration is invoked, the orchestration returns immediately with a handler that can be used to get the result later. This asynchronous pattern allows a more flexible and responsive design, especially in scenarios where the orchestration may take a long time to complete.
调用业务流程时，业务流程会立即返回一个处理程序，该处理程序可用于稍后获取结果。这种异步模式允许更灵活和响应式设计，尤其是在业务流程可能需要很长时间才能完成的情况下。

 Important  重要

If a timeout occurs, the invocation of the orchestration will not be cancelled. The orchestration will continue to run in the background until it completes. Developers can still retrieve the result later.
如果发生超时，则不会取消业务流程的调用。业务流程将继续在后台运行，直到完成。开发人员稍后仍可以检索结果。

Developers can get the result of the an orchestration invocation later by calling the `GetValueAsync` method on the result object. When the application is ready to process the result, the invocation may or may not have completed. Therefore, developers can optionally specify a timeout for the `GetValueAsync` method. If the orchestration does not complete within the specified timeout, a timeout exception will be thrown.
开发人员稍后可以通过对结果对象调用 `GetValueAsync` 方法来获取业务流程调用的结果。当应用程序准备好处理结果时，调用可能已完成，也可能未完成。因此，开发人员可以选择为 `GetValueAsync` 方法指定超时。如果业务流程未在指定的超时内完成，则会引发超时异常。

C#Copy  复制

```csharp
string output = await result.GetValueAsync(TimeSpan.FromSeconds(60));
```

If the orchestration does not complete within the specified timeout, a timeout exception will be thrown.
如果业务流程未在指定的超时内完成，则会引发超时异常。



## Human-in-the-loop  人机交互



### Agent Response Callback  代理响应回调

To see agent responses inside an invocation, developers can provide a `ResponseCallback` to the orchestration. This allows developers to observe the responses from each agent during the orchestration process. Developers can use this callback for UI updates, logging, or other purposes.
若要查看调用中的代理响应，开发人员可以向业务流程提供 `ResponseCallback`。这允许开发人员在编排过程中观察每个代理的响应。开发人员可以将此回调用于界面更新、日志记录或其他目的。

C#Copy  复制

```csharp
public ValueTask ResponseCallback(ChatMessageContent response)
{
    Console.WriteLine($"# {response.AuthorName}\n{response.Content}");
    return ValueTask.CompletedTask;
}

SequentialOrchestration orchestration = new SequentialOrchestration(
    analystAgent, writerAgent, editorAgent)
{
    ResponseCallback = ResponseCallback,
};
```



### Human Response Function  人工响应功能

For orchestrations that supports user input (e.g., handoff and group chat), provide an `InteractiveCallback` that returns a `ChatMessageContent` from the user. By using this callback, developers can implement custom logic to gather user input, such as displaying a UI prompt or integrating with other systems.
对于支持用户输入的业务流程（例如，切换和群聊），请提供一个 `InteractiveCallback，该 InteractiveCallback` 从用户返回 `ChatMessageContent`。通过使用此回调，开发人员可以实现自定义逻辑来收集用户输入，例如显示 UI 提示或与其他系统集成。

C#Copy  复制

```csharp
HandoffOrchestration orchestration = new(...)
{
    InteractiveCallback = () =>
    {
        Console.Write("User: ");
        string input = Console.ReadLine();
        return new ChatMessageContent(AuthorRole.User, input);
    }
};
```



## Structured Data  结构化数据

We believe that structured data is a key part in building agentic workflows. By using structured data, developers can create more reuseable orchestrations and the development experience is improved. The Semantic Kernel SDK provides a way to pass structured data as input to orchestrations and return structured data as output.
我们相信结构化数据是构建代理工作流程的关键部分。通过使用结构化数据，开发人员可以创建更多可重用的业务流程，并改善开发体验。语义内核 SDK 提供了一种将结构化数据作为业务流程的输入传递并将结构化数据作为输出返回的方法。

 Important  重要

Internally, the orchestrations still process data as `ChatMessageContent`.
在内部，业务流程仍将数据作为 `ChatMessageContent` 进行处理。



### Structured Inputs  结构化输入

Developers can pass structured data as input to orchestrations by using a strongly-typed input class and specifying it as the generic parameter for the orchestration. This enables type safety and more flexibility for orchestrations to handle complex data structures. For example, to triage GitHub issues, define a class for the structured input:
开发人员可以通过使用强类型输入类并将其指定为业务流程的泛型参数，将结构化数据作为输入传递给业务流程。这为业务流程提供了处理复杂数据结构的类型安全和更大的灵活性。例如，若要对 GitHub 问题进行分类，请为结构化输入定义一个类：

C#Copy  复制

```csharp
public sealed class GithubIssue
{
    public string Id { get; set; } = string.Empty;
    public string Title { get; set; } = string.Empty;
    public string Body { get; set; } = string.Empty;
    public string[] Labels { get; set; } = [];
}
```

Developers can then use this type as the input to an orchestration by providing it as the generic parameter:
然后，开发人员可以通过将此类型作为泛型参数提供来将其用作业务流程的输入：

C#Copy  复制

```csharp
HandoffOrchestration<GithubIssue, string> orchestration =
    new(...);

GithubIssue input = new GithubIssue { ... };
var result = await orchestration.InvokeAsync(input, runtime);
```



#### Custom Input Transforms  自定义输入转换

By default, the orchestration will use the built-in input transform, which serializes the object to JSON and wraps it in a `ChatMessageContent`. If you want to customize how your structured input is converted to the underlying message type, you can provide your own input transform function via the `InputTransform` property:
默认情况下，业务流程将使用内置输入转换，该转换将对象序列化为 JSON，并将其包装在 `ChatMessageContent` 中。如果要自定义结构化输入转换为基础消息类型的方式，可以通过 `InputTransform` 属性提供自己的输入转换函数：

C#Copy  复制

```csharp
HandoffOrchestration<GithubIssue, string> orchestration =
    new(...)
    {
        InputTransform = (issue, cancellationToken) =>
        {
            // For example, create a chat message with a custom format
            var message = new ChatMessageContent(AuthorRole.User, $"[{issue.Id}] {issue.Title}\n{issue.Body}");
            return ValueTask.FromResult<IEnumerable<ChatMessageContent>>([message]);
        },
    };
```

This allows you to control exactly how your typed input is presented to the agents, enabling advanced scenarios such as custom formatting, field selection, or multi-message input.
这使您可以准确控制键入的输入呈现给代理的方式，从而实现自定义格式、字段选择或多消息输入等高级场景。

 Tip  提示

See the full sample in [Step04a_HandoffWithStructuredInput.cs](https://github.com/microsoft/semantic-kernel/blob/main/dotnet/samples/GettingStartedWithAgents/Orchestration/Step04a_HandoffWithStructuredInput.cs)
查看完整示例 [Step04a_HandoffWithStructuredInput.cs](https://github.com/microsoft/semantic-kernel/blob/main/dotnet/samples/GettingStartedWithAgents/Orchestration/Step04a_HandoffWithStructuredInput.cs)



### Structured Outputs  结构化输出

Agents and orchestrations can return structured outputs by specifying a strongly-typed output class as the generic parameter for the orchestration. This enables you to work with rich, structured results in your application, rather than just plain text.
代理和业务流程可以通过将强类型输出类指定为业务流程的泛型参数来返回结构化输出。这使您能够在应用程序中使用丰富的结构化结果，而不仅仅是纯文本。

For example, suppose you want to analyze an article and extract themes, sentiments, and entities. Define a class for the structured output:
例如，假设您要分析一篇文章并提取主题、情绪和实体。为结构化输出定义一个类：

C#Copy  复制

```csharp
public sealed class Analysis
{
    public IList<string> Themes { get; set; } = [];
    public IList<string> Sentiments { get; set; } = [];
    public IList<string> Entities { get; set; } = [];
}
```

You can then use this type as the output for your orchestration by providing it as the generic parameter:
然后，可以通过将此类型作为泛型参数提供，将其用作业务流程的输出：

C#Copy  复制

```csharp
ConcurrentOrchestration<string, Analysis> orchestration =
    new(agent1, agent2, agent3)
    {
        ResultTransform = outputTransform.TransformAsync, // see below
    };

// ...
OrchestrationResult<Analysis> result = await orchestration.InvokeAsync(input, runtime);
Analysis output = await result.GetValueAsync(TimeSpan.FromSeconds(60));
```



#### Custom Output Transforms  自定义输出变换

By default, the orchestration will use the built-in output transform, which attempts to deserialize the agent's response content to your output type. For more advanced scenarios, you can provide a custom output transform (for example, with structured output by some models).
默认情况下，业务流程将使用内置输出转换，该转换会尝试将代理的响应内容反序列化为输出类型。对于更高级的方案，可以提供自定义输出转换（例如，某些模型的结构化输出）。

C#Copy  复制

```csharp
StructuredOutputTransform<Analysis> outputTransform =
    new(chatCompletionService, new OpenAIPromptExecutionSettings { ResponseFormat = typeof(Analysis) });

ConcurrentOrchestration<string, Analysis> orchestration =
    new(agent1, agent2, agent3)
    {
        ResultTransform = outputTransform.TransformAsync,
    };
```

This approach allows you to receive and process structured data directly from the orchestration, making it easier to build advanced workflows and integrations.
这种方法允许您直接从编排接收和处理结构化数据，从而更轻松地构建高级工作流程和集成。

 Tip  提示

See the full sample in [Step01a_ConcurrentWithStructuredOutput.cs](https://github.com/microsoft/semantic-kernel/blob/main/dotnet/samples/GettingStartedWithAgents/Orchestration/Step01a_ConcurrentWithStructuredOutput.cs)
查看完整示例 [Step01a_ConcurrentWithStructuredOutput.cs](https://github.com/microsoft/semantic-kernel/blob/main/dotnet/samples/GettingStartedWithAgents/Orchestration/Step01a_ConcurrentWithStructuredOutput.cs)



## Cancellation  取消

 Important  重要

Cancellation will stop the agents from processing any further messages, but it will not stop agents that are already processing messages.
取消将停止代理处理任何进一步的消息，但不会停止已在处理消息的代理。

 Important  重要

Cancellation will not stop the runtime.
取消不会停止运行时。

You can cancel an orchestration by calling the `Cancel` method on the result handler. This will stop the orchestration by propagating the signal to all agents, and they will stop processing any further messages.
可以通过在结果处理程序上调用 `Cancel` 方法来取消业务流程。这将通过将信号传播到所有代理来停止业务流程，并且它们将停止处理任何进一步的消息。

C#Copy  复制

```csharp
var resultTask = orchestration.InvokeAsync(input, runtime);
resultTask.Cancel();
```



## Next steps  后续步骤

[  更多代码示例](https://github.com/microsoft/semantic-kernel/tree/main/dotnet/samples/GettingStartedWithAgents/Orchestration)