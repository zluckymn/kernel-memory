# Group Chat Orchestration  群聊编排

- 05/23/2025



Agent Orchestration features in the Agent Framework are in the experimental stage. They are under active development and may change significantly before advancing to the preview or release candidate stage.
代理框架中的代理业务流程功能处于实验阶段。它们正在积极开发中，在进入预览版或候选版本阶段之前可能会发生重大变化。

Group chat orchestration models a collaborative conversation among agents, optionally including a human participant. A group chat manager coordinates the flow, determining which agent should respond next and when to request human input. This pattern is powerful for simulating meetings, debates, or collaborative problem-solving sessions.
群聊编排对代理之间的协作对话进行建模，可以选择包括人类参与者。群聊管理器协调流程，确定接下来应该响应哪个代理以及何时请求人工输入。此模式对于模拟会议、辩论或协作解决问题的会议非常强大。

To learn more about the pattern, such as when to use the pattern or when to avoid the pattern in your workload, see [Group chat orchestration](https://learn.microsoft.com/en-us/azure/architecture/ai-ml/guide/ai-agent-design-patterns#group-chat-orchestration).
若要了解有关该模式的详细信息，例如何时使用该模式或何时避免工作负载中的该模式，请参阅群[聊业务流程 ](https://learn.microsoft.com/en-us/azure/architecture/ai-ml/guide/ai-agent-design-patterns#group-chat-orchestration)。



## Common Use Cases  常见用例

Agents representing different departments discuss a business proposal, with a manager agent moderating the conversation and involving a human when needed:
代表不同部门的代理讨论业务提案，经理代理主持对话并在需要时让人员参与进来：

![diagram](https://learn.microsoft.com/en-us/semantic-kernel/media/multi-agent-group-chat.png)



## What You'll Learn  您将学到什么

- How to define agents with different roles for a group chat
  如何为群聊定义具有不同角色的代理
- How to use a group chat manager to control the flow of conversation
  如何使用群聊管理器控制对话流程
- How to involve a human participant in the conversation
  如何让人类参与者参与对话
- How to observe the conversation and collect the final result
  如何观察对话并收集最终结果



### Define Your Agents  定义您的代理

Each agent in the group chat has a specific role. In this example, we define a copywriter and a reviewer.
群聊中的每个代理都有特定的角色。在此示例中，我们定义了文案和审阅者。

 Tip  提示

The [`ChatCompletionAgent`](https://learn.microsoft.com/en-us/semantic-kernel/frameworks/agent/agent-types/chat-completion-agent) is used here, but you can use any [agent type](https://learn.microsoft.com/en-us/semantic-kernel/frameworks/agent/agent-architecture#agent-types-in-semantic-kernel).
此处使用 [`ChatCompletionAgent`](https://learn.microsoft.com/en-us/semantic-kernel/frameworks/agent/agent-types/chat-completion-agent)，但您可以使用任何[代理类型 ](https://learn.microsoft.com/en-us/semantic-kernel/frameworks/agent/agent-architecture#agent-types-in-semantic-kernel)。

C#Copy  复制

```csharp
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Orchestration;
using Microsoft.SemanticKernel.Agents.Orchestration.GroupChat;
using Microsoft.SemanticKernel.Agents.Runtime.InProcess;

// Create a kernel with an AI service
Kernel kernel = ...;

ChatCompletionAgent writer = new ChatCompletionAgent {
    Name = "CopyWriter",
    Description = "A copy writer",
    Instructions = "You are a copywriter with ten years of experience and are known for brevity and a dry humor. The goal is to refine and decide on the single best copy as an expert in the field. Only provide a single proposal per response. You're laser focused on the goal at hand. Don't waste time with chit chat. Consider suggestions when refining an idea.",
    Kernel = kernel,
};

ChatCompletionAgent editor = new ChatCompletionAgent {
    Name = "Reviewer",
    Description = "An editor.",
    Instructions = "You are an art director who has opinions about copywriting born of a love for David Ogilvy. The goal is to determine if the given copy is acceptable to print. If so, state that it is approved. If not, provide insight on how to refine suggested copy without example.",
    Kernel = kernel,
};
```



### Optional: Observe Agent Responses 可选：观察代理响应

You can create a callback to capture agent responses as the sequence progresses via the `ResponseCallback` property.
您可以创建回调，以通过 `ResponseCallback` 属性在序列进行时捕获代理响应。

C#Copy  复制

```csharp
ChatHistory history = [];

ValueTask responseCallback(ChatMessageContent response)
{
    history.Add(response);
    return ValueTask.CompletedTask;
}
```



### Set Up the Group Chat Orchestration 设置群聊编排

Create a `GroupChatOrchestration` object, passing in the agents, a group chat manager (here, a `RoundRobinGroupChatManager`), and the response callback. The manager controls the flow—here, it alternates turns in a round-robin fashion for a set number of rounds.
创建一个 `GroupChatOrchestration` 对象，传入代理、群聊管理器（此处为 `RoundRobinGroupChatManager`）和响应回调。经理控制流程——在这里，它以循环方式交替轮换一定数量的回合。

C#Copy  复制

```csharp
GroupChatOrchestration orchestration = new GroupChatOrchestration(
    new RoundRobinGroupChatManager { MaximumInvocationCount = 5 },
    writer,
    editor)
{
    ResponseCallback = responseCallback,
};
```



### Start the Runtime  启动运行时

A runtime is required to manage the execution of agents. Here, we use `InProcessRuntime` and start it before invoking the orchestration.
需要运行时来管理代理的执行。在这里，我们使用 `InProcessRuntime` 并在调用业务流程之前启动它。

C#Copy  复制

```csharp
InProcessRuntime runtime = new InProcessRuntime();
await runtime.StartAsync();
```



### Invoke the Orchestration  调用业务流程

Invoke the orchestration with your initial task (e.g., "Create a slogan for a new electric SUV..."). The agents will take turns responding, refining the result.
使用初始任务调用业务流程（例如，“为新的电动 SUV 创建口号...”）。代理将轮流响应，完善结果。

C#Copy  复制

```csharp
var result = await orchestration.InvokeAsync(
    "Create a slogan for a new electric SUV that is affordable and fun to drive.",
    runtime);
```



### Collect Results  收集结果

Wait for the orchestration to complete and retrieve the final output.
等待业务流程完成并检索最终输出。

C#Copy  复制

```csharp
string output = await result.GetValueAsync(TimeSpan.FromSeconds(60));
Console.WriteLine($"\n# RESULT: {text}");
Console.WriteLine("\n\nORCHESTRATION HISTORY");
foreach (ChatMessageContent message in history)
{
    this.WriteAgentChatMessage(message);
}
```



### Optional: Stop the Runtime 可选：停止运行时

After processing is complete, stop the runtime to clean up resources.
处理完成后，停止运行时以清理资源。

C#Copy  复制

```csharp
await runtime.RunUntilIdleAsync();
```



### Sample Output  示例输出

plaintext  明文Copy  复制

```plaintext
# RESULT: “Affordable Adventure: Drive Electric, Drive Fun.”


ORCHESTRATION HISTORY

# Assistant - CopyWriter: “Charge Ahead: Affordable Thrills, Zero Emissions.”

# Assistant - Reviewer: The slogan is catchy but it could be refined to better ...

# Assistant - CopyWriter: “Electrify Your Drive: Fun Meets Affordability.”

# Assistant - Reviewer: The slogan captures the essence of electric driving and ...

# Assistant - CopyWriter: “Affordable Adventure: Drive Electric, Drive Fun.”
```

 Tip  提示

The full sample code is available [here](https://github.com/microsoft/semantic-kernel/blob/main/dotnet/samples/GettingStartedWithAgents/Orchestration/Step03_GroupChat.cs)
完整的示例代码可在[此处](https://github.com/microsoft/semantic-kernel/blob/main/dotnet/samples/GettingStartedWithAgents/Orchestration/Step03_GroupChat.cs)获得



### Customize the Group Chat Manager 自定义群聊管理器

You can customize the group chat flow by implementing your own `GroupChatManager`. This allows you to control how results are filtered, how the next agent is selected, and when to request user input or terminate the chat.
您可以通过实施自己的 `GroupChatManager` 来自定义群聊流程。这使您可以控制如何过滤结果、如何选择下一个代理以及何时请求用户输入或终止聊天。

For example, you can create a custom manager by inheriting from `GroupChatManager` and overriding its abstract methods:
例如，您可以通过继承 `GroupChatManager` 并重写其抽象方法来创建自定义管理器：

C#Copy  复制

```csharp
using Microsoft.SemanticKernel.Agents.Orchestration.GroupChat;
using Microsoft.SemanticKernel.ChatCompletion;
using System.Threading;
using System.Threading.Tasks;

public class CustomGroupChatManager : GroupChatManager
{
    public override ValueTask<GroupChatManagerResult<string>> FilterResults(ChatHistory history, CancellationToken cancellationToken = default)
    {
        // Custom logic to filter or summarize chat results
        return ValueTask.FromResult(new GroupChatManagerResult<string>("Summary") { Reason = "Custom summary logic." });
    }

    public override ValueTask<GroupChatManagerResult<string>> SelectNextAgent(ChatHistory history, GroupChatTeam team, CancellationToken cancellationToken = default)
    {
        // Randomly select an agent from the team
        var random = new Random();
        int index = random.Next(team.Members.Count);
        string nextAgent = team.Members[index].Id;
        return ValueTask.FromResult(new GroupChatManagerResult<string>(nextAgent) { Reason = "Custom selection logic." });
    }

    public override ValueTask<GroupChatManagerResult<bool>> ShouldRequestUserInput(ChatHistory history, CancellationToken cancellationToken = default)
    {
        // Custom logic to decide if user input is needed
        return ValueTask.FromResult(new GroupChatManagerResult<bool>(false) { Reason = "No user input required." });
    }

    public override ValueTask<GroupChatManagerResult<bool>> ShouldTerminate(ChatHistory history, CancellationToken cancellationToken = default)
    {
        // Optionally call the base implementation to check for default termination logic
        var baseResult = base.ShouldTerminate(history, cancellationToken).Result;
        if (baseResult.Value)
        {
            // If the base logic says to terminate, respect it
            return ValueTask.FromResult(baseResult);
        }

        // Custom logic to determine if the chat should terminate
        bool shouldEnd = history.Count > 10; // Example: end after 10 messages
        return ValueTask.FromResult(new GroupChatManagerResult<bool>(shouldEnd) { Reason = "Custom termination logic." });
    }
}
```

You can then use your custom manager in the orchestration:
然后，可以在业务流程中使用自定义管理器：

C#Copy  复制

```csharp
GroupChatOrchestration orchestration = new (new CustomGroupChatManager { MaximumInvocationCount = 5 }, ...);
```

 Tip  提示

A complete example of a custom group chat manager is available [here](https://github.com/microsoft/semantic-kernel/blob/main/dotnet/samples/GettingStartedWithAgents/Orchestration/Step03b_GroupChatWithAIManager.cs)
自定义群聊管理器的完整示例可在[此处](https://github.com/microsoft/semantic-kernel/blob/main/dotnet/samples/GettingStartedWithAgents/Orchestration/Step03b_GroupChatWithAIManager.cs)找到



### Order of Group Chat Manager Function Calls 群聊管理器函数调用的顺序

When orchestrating a group chat, the group chat manager's methods are called in a specific order for each round of the conversation:
编排群聊时，群聊管理器的方法会针对每一轮对话按特定顺序调用：

1. **ShouldRequestUserInput**: Checks if user (human) input is required before the next agent speaks. If true, the orchestration pauses for user input. The user input is then added to the chat history of the manager and sent to all agents.
   **ShouldRequestUserInput**：检查在下一个代理说话之前是否需要用户（人工）输入。如果为 true，则业务流程将暂停以进行用户输入。然后，用户输入将添加到经理的聊天历史记录中，并发送给所有代理。
2. **ShouldTerminate**: Determines if the group chat should end (for example, if a maximum number of rounds is reached or a custom condition is met). If true, the orchestration proceeds to result filtering.
   **ShouldTerminate**：确定群聊是否应结束（例如，是否达到最大轮数或满足自定义条件）。如果为 true，则业务流程将继续进行结果筛选。
3. **FilterResults**: Called only if the chat is terminating, to summarize or process the final results of the conversation.
   **FilterResults**：仅在聊天终止时调用，以汇总或处理对话的最终结果。
4. **SelectNextAgent**: If the chat is not terminating, selects the next agent to respond in the conversation.
   **SelectNextAgent**：如果聊天未终止，则选择下一个代理在对话中做出响应。

This order ensures that user input and termination conditions are checked before advancing the conversation, and that results are filtered only at the end. You can customize the logic for each step by overriding the corresponding methods in your custom group chat manager.
此顺序可确保在推进对话之前检查用户输入和终止条件，并且仅在最后筛选结果。您可以通过覆盖自定义群聊管理器中的相应方法来自定义每个步骤的逻辑。



## Next steps  后续步骤

[  切换编排](https://learn.microsoft.com/en-us/semantic-kernel/frameworks/agent/agent-orchestration/handoff)