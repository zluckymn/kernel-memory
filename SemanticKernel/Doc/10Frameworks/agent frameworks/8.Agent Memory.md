# Using memory with Agents  将内存与代理一起使用

- 06/09/2025



 Warning  警告

The Semantic Kernel Agent Memory functionality is experimental, is subject to change and will only be finalized based on feedback and evaluation.
Semantic Kernel代理内存功能是实验性的，可能会发生变化，并且只会根据反馈和评估最终确定。

It's often important for an agent to remember important information. This information may be retained for the duration of a conversation or longer term to span multiple conversations. The information may be learned from interacting with a user and may be specific to that user.
对于代理来说，记住重要信息通常很重要。此信息可能会在对话期间保留，也可以保留更长时间以跨越多个对话。这些信息可以从与用户的交互中获知，并且可能特定于该用户。

We call this information memories.
我们称之为信息记忆。

To capture and retain memories, we support components that can be used with an `AgentThread` to extract memories from any messages that are added to the thread, and provide those memories to the agent as needed.
为了捕获和保留内存，我们支持可与 `AgentThread` 一起使用的组件，以从添加到线程的任何消息中提取内存，并根据需要将这些内存提供给代理。



## Using Mem0 for Agent memory 将 Mem0 用于代理内存

[Mem0](https://mem0.ai/) is a self-improving memory layer for LLM applications, enabling personalized AI experiences.
[Mem0](https://mem0.ai/) 是用于 LLM 应用程序的自我改进内存层，可实现个性化的 AI 体验。

The `Microsoft.SemanticKernel.Memory.Mem0Provider` integrates with the Mem0 service allowing agents to remember user preferences and context across multiple threads, enabling a seamless user experience.
它 `Microsoft.SemanticKernel.Memory.Mem0Provider` 与 Mem0 服务集成，允许代理跨多个线程记住用户偏好和上下文，从而实现无缝的用户体验。

Each message added to the thread is sent to the Mem0 service to extract memories. For each agent invocation, Mem0 is queried for memories matching the provided user request, and any memories are added to the agent context for that invocation.
添加到线程中的每条消息都会发送到 Mem0 服务以提取内存。对于每个代理调用，都会查询 Mem0 以查找与提供的用户请求匹配的内存，并将任何内存添加到该调用的代理上下文中。

The Mem0 memory provider can be configured with a user id to allow storing memories about the user, long term, across multiple threads. It can also be configured with a thread id or to use the thread id of the agent thread, to allow for short term memories that are only attached to a single thread.
Mem0 内存提供程序可以配置用户 ID，以允许跨多个线程长期存储有关用户的内存。它还可以配置线程 ID 或使用代理线程的线程 ID，以允许仅附加到单个线程的短期内存。

Here is an example of how to use this component.
下面是如何使用此组件的示例。

C#Copy  复制

```csharp
// Create an HttpClient for the Mem0 service.
using var httpClient = new HttpClient()
{
    BaseAddress = new Uri("https://api.mem0.ai")
};
httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Token", "<Your_Mem0_API_Key>");

// Create a Mem0 provider for the current user.
var mem0Provider = new Mem0Provider(httpClient, options: new()
{
    UserId = "U1"
});

// Clear any previous memories (optional).
await mem0Provider.ClearStoredMemoriesAsync();

// Add the mem0 provider to the agent thread.
ChatHistoryAgentThread agentThread = new();
agentThread.AIContextProviders.Add(mem0Provider);

// Use the agent with mem0 memory.
ChatMessageContent response = await agent.InvokeAsync("Please retrieve my company report", agentThread).FirstAsync();
Console.WriteLine(response.Content);
```



### Mem0Provider options  Mem0Provider 选项

The `Mem0Provider` can be configured with various options to customize its behavior. Options are provided using the `Mem0ProviderOptions` class to the `Mem0Provider` constructor.
`Mem0Provider` 可以配置各种选项来自定义其行为。使用 `Mem0ProviderOptions` 类向 `Mem0Provider` 构造函数提供选项。



#### Scoping Options  范围选项

Mem0 provides the ability to scope memories by Application, Agent, Thread and User.
Mem0 提供了按应用程序、代理、线程和用户确定内存范围的功能。

Options are available to provide ids for these scopes, so that the memories can be stored in mem0 under these ids. See the `ApplicationId`, `AgentId`, `ThreadId` and `UserId` properties on `Mem0ProviderOptions`.
可以使用选项为这些作用域提供 ID，以便内存可以存储在这些 ID 下的 mem0 中。请参阅 `Mem0ProviderOptions` 上的 `ApplicationId`、`AgentId`、`ThreadId` 和 `UserId` 属性。

In some cases you may want to use the thread id of the server side agent thread, when using a service based agent. The thread may however not have been created yet when the `Mem0Provider` object is being constructed. In this case, you can set the `ScopeToPerOperationThreadId` option to `true`, and the `Mem0Provider` will use the id of the `AgentThread` when it is available.
在某些情况下，在使用基于服务的代理时，您可能希望使用服务器端代理线程的线程 ID。但是，在构造 `Mem0Provider` 对象时，线程可能尚未创建。在这种情况下，您可以将 `ScopeToPerOperationThreadId` 选项设置为 `true`，并且 `Mem0Provider` 将在 `AgentThread` 可用时使用 id。



#### Context Prompt  上下文提示

The `ContextPrompt` option allows you to override the default prompt that is prefixed to memories. The prompt is used to contextualize the memories provided to the AI model, so that the AI model knows what they are and how to use them.
`ContextPrompt` 选项允许您覆盖以记忆为前缀的默认提示。提示用于将提供给 AI 模型的记忆置于上下文中，以便 AI 模型知道它们是什么以及如何使用它们。



## Using Whiteboard Memory for Short-Term Context 将白板记忆用于短期上下文

The whiteboard memory feature allows agents to capture and retain the most relevant information from a conversation, even when the chat history is truncated.
白板记忆功能允许代理从对话中捕获和保留最相关的信息，即使聊天记录被截断也是如此。

Each message added to the conversation is processed by the `Microsoft.SemanticKernel.Memory.WhiteboardProvider` to extract requirements, proposals, decisions, actions. These are stored on a whiteboard and provided to the agent as additional context on each invocation.
添加到对话中的每条消息都由 处理 `Microsoft.SemanticKernel.Memory.WhiteboardProvider` ，以提取需求、建议、决策、作。这些存储在白板上，并作为每次调用的附加上下文提供给代理。

Here is an example of how to set up Whiteboard Memory:
以下是如何设置白板内存的示例：

C#Copy  复制

```csharp
// Create a whiteboard provider.
var whiteboardProvider = new WhiteboardProvider(chatClient);

// Add the whiteboard provider to the agent thread.
ChatHistoryAgentThread agentThread = new();
agentThread.AIContextProviders.Add(whiteboardProvider);

// Simulate a conversation with the agent.
await agent.InvokeAsync("I would like to book a trip to Paris.", agentThread);

// Whiteboard should now contain a requirement that the user wants to book a trip to Paris.
```

Benefits of Whiteboard Memory
白板内存的好处

- Short-Term Context: Retains key information about the goals of ongoing conversations.
  短期背景：保留有关正在进行的对话目标的关键信息。
- Allows Chat History Truncation: Supports maintaining critical context if the chat history is truncated.
  允许截断聊天记录：如果聊天记录被截断，则支持维护关键上下文。



### WhiteboardProvider options WhiteboardProvider 选项

The `WhiteboardProvider` can be configured with various options to customize its behavior. Options are provided using the `WhiteboardProviderOptions` class to the `WhiteboardProvider` constructor.
`WhiteboardProvider` 可以配置各种选项来自定义其行为。使用 `WhiteboardProviderOptions` 类向 `WhiteboardProvider` 构造函数提供选项。



#### MaxWhiteboardMessages  MaxWhiteboard 消息

Specifies a maximum number of messages to retain on the whiteboard. When the maximum is reached, less valuable messages will be removed.
指定要在白板上保留的最大消息数。当达到最大值时，将删除价值较低的邮件。



#### ContextPrompt  上下文提示

When providing the whiteboard contents to the AI model it's important to describe what the messages are for. This setting allows overriding the default messaging that is built into the `WhiteboardProvider`.
向 AI 模型提供白板内容时，描述消息的用途非常重要。此设置允许重写 `WhiteboardProvider` 中内置的默认消息传递。



#### WhiteboardEmptyPrompt  白板空提示

When the whiteboard is empty, the `WhiteboardProvider` outputs a message saying that it is empty. This setting allows overriding the default messaging that is built into the `WhiteboardProvider`.
当白板为空时，`WhiteboardProvider` 会输出一条消息，指出它为空。此设置允许重写 `WhiteboardProvider` 中内置的默认消息传递。



#### MaintenancePromptTemplate 维护提示模板

The `WhiteboardProvider` uses an AI model to add/update/remove messages on the whiteboard. It has a built in prompt for making these updates. This setting allows overriding this built-in prompt.
`WhiteboardProvider` 使用 AI 模型在白板上添加/更新/删除消息。它有一个内置的提示来进行这些更新。此设置允许覆盖此内置提示。

The following parameters can be used in the template:
模板中可以使用以下参数：

- `{{$maxWhiteboardMessages}}`: The maximum number of messages allowed on the whiteboard.
  `{{$maxWhiteboardMessages}}`：白板上允许的最大消息数。
- `{{$inputMessages}}`: The input messages to be added to the whiteboard.
  `{{$inputMessages}}：` 要添加到白板的输入消息。
- `{{$currentWhiteboard}}`: The current state of the whiteboard.
  `{{$currentWhiteboard}}`：白板的当前状态。



## Combining Mem0 and Whiteboard Memory 结合 Mem0 和白板内存

You can use both Mem0 and whiteboard memory in the same agent to achieve a balance between long-term and short-term memory capabilities.
您可以在同一代理中同时使用 Mem0 和白板内存，以实现长期记忆和短期记忆能力之间的平衡。

C#Copy  复制

```csharp
// Add both Mem0 and whiteboard providers to the agent thread.
agentThread.AIContextProviders.Add(mem0Provider);
agentThread.AIContextProviders.Add(whiteboardProvider);

// Use the agent with combined memory capabilities.
ChatMessageContent response = await agent.InvokeAsync("Please retrieve my company report", agentThread).FirstAsync();
Console.WriteLine(response.Content);
```

By combining these memory features, agents can provide a more personalized and context-aware experience for users.
通过结合这些内存功能，代理可以为用户提供更加个性化和上下文感知的体验。



## Next steps  后续步骤

 