# 使用 C# 学习 Semantic Kernel 的 8 个步骤

![1753960026983](C:\Users\MN\AppData\Roaming\Typora\typora-user-images\1753960026983.png)

学习如何使用 Semantic Kernel for C# 来构建 AI 应用程序的 8 个关键步骤。

## 1. 获取核心 Kernel

[相关链接](https://www.google.com/search?q=https://aka.ms/sk/kernel)

首先，将 NuGet 包导入到您的项目中。这是使用 Semantic Kernel 的基础。

```
// 首次将 NuGet 包导入您的项目
#r "nuget: Microsoft.SemanticKernel"

// 使用该包
using Microsoft.SemanticKernel;
using Kernel = Microsoft.SemanticKernel.Kernel;

IKernelBuilder builder = Kernel.CreateBuilder();
```

## 2. 添加 AI 服务

[相关链接](https://www.google.com/search?q=https://aka.ms/sk/aiservices)

Semantic Kernel 允许您根据需求添加和更换不同的 AI 服务。除了 Azure OpenAI 和 OpenAI, Semantic Kernel 还支持 Google Gemini, MistralAI, Ollama, 本地模型等等。

```
// Azure OpenAI 示例
builder.AddAzureOpenAIChatCompletion(AOAI_DEP_NAME, AOAI_ENDPOINT, AOAI_KEY);

// OpenAI 示例
builder.AddOpenAIChatCompletion(OAI_MODEL_NAME, OAI_KEY);

// 其他模型
builder.AddAzureOpenAIAudioToText(AOAI_DEP_NAME, AOAI_ENDPOINT, AOAI_KEY);
builder.AddAzureOpenAITextToAudio(AOAI_DEP_NAME, AOAI_ENDPOINT, AOAI_KEY);
builder.AddAzureOpenAITextToImage(AOAI_DEP_NAME, AOAI_ENDPOINT, AOAI_KEY);

// 其他服务
builder.AddGoogleAIGeminiChatCompletion(GG_DEP_NAME, GG_DEP_KEY);
builder.AddMistralChatCompletion(MAI_MODEL_ID, MAI_KEY);
builder.AddOllamaChatCompletion(OLLAMA_MODEL_ID, OLLAMA_URI);
builder.AddOnnxRuntimeGenAIChatCompletion(ONNX_MODEL_ID, ONNX_MODEL_PATH);
```

## 3. 添加插件

[相关链接](https://www.google.com/search?q=https://aka.ms/sk/plugins)

插件是扩展 Kernel 功能的一种方式。根据插件的存储位置，添加方式有所不同。

```
// 从 OpenAPI 导入 (最常见)
var plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync(
    pluginName: "WeatherForecast",
    uri: new Uri($"http://localhost:5134/swagger/v1/swagger.json"));
builder.Plugins.Add(plugin);

// 从类型导入
builder.Plugins.AddFromType<TimeInformation>();

class TimeInformation
{
    [KernelFunction]
    [Description("Get the current time in UTC")]
    public string GetCurrentUtcTime() => DateTime.UtcNow.ToString("R");
}

// 从对象添加
builder.Plugins.AddFromObject(new MyPlugin());

// 从文件目录导入
builder.Plugins.AddFromPromptDirectory("path/to/plugins");
```

## 4. 添加筛选器和遥测

[相关链接](https://www.google.com/search?q=https://aka.ms/sk/filters)

为每个服务设置跟踪级别，并使用遥测包设置记录器以进行监控和调试。

```
// 使用遥测包设置记录器并附加到服务
ILogger logger = LoggerFactory.Create(builder => builder.AddConsole()).CreateLogger("SemanticKernel");
builder.Services.AddSingleton(logger);

// 添加筛选器
builder.Services.AddSingleton<IPromptRenderFilter, PromptRenderLoggingFilter>();

class PromptRenderLoggingFilter : IPromptRenderFilter
{
    private readonly ILogger _logger;
    public PromptRenderLoggingFilter(ILogger logger) => _logger = logger;
    public async Task OnPromptRenderAsync(PromptRenderContext context, Func<Task> next)
    {
        await next(context);
        _logger.LogInformation($"Prompt: {context.RenderedPrompt}");
        // context.RenderedPrompt = ValidateWithPromptShields(context.RenderedPrompt);
    }
}
```

## 5. 构建 Kernel

构建 Kernel 会将前面所有步骤中配置的服务、插件和设置整合在一起。

```
// 构建 Kernel 会附加之前步骤的所有内容
Kernel kernel = builder.Build();
```

## 6. 添加内存

[相关链接](https://aka.ms/sk/memory)

Semantic Kernel 提供了多种到向量数据库的内存存储连接器，可用于存储和检索信息。包括 Azure AI Search, Chroma, DuckDB, Milvus, Pinecone, Qdrant, Redis, Weaviate 等。

```
// 定义内存记录结构
class Glossary
{
    [VectorStoreRecordKey]
    public ulong Key { get; set; }
    [VectorStoreRecordData]
    public required string Term { get; set; }
    [VectorStoreRecordData]
    public required string Definition { get; set; }
    [VectorStoreRecordVector(1536)]
    public ReadOnlyMemory<float> DefinitionEmbedding { get; set; }
}

// 构建一个内存向量存储，这里可以替换为任何数据连接器
var vectorStore = new InMemoryVectorStore();
var collection = vectorStore.GetCollection<ulong, Glossary>("skglossary");
await collection.CreateCollectionIfNotExistsAsync();

// 创建一个嵌入生成服务
var textEmbeddingService = new AzureOpenAITextEmbeddingGenerationService(AOAI_EMBEDDING_DEP_NAME, AOAI_ENDPOINT, AOAI_KEY);

// 生成嵌入
var entries = Glossary.ContentEntriesLists();
var tasks = entries.Select(async entry =>
{
    entry.DefinitionEmbedding = await textEmbeddingService.GenerateEmbeddingAsync(entry.Term);
});
await Task.WhenAll(tasks);

// 将条目插入集合并返回它们的键
var upsertKeys = await Task.WhenAll(entries.Select(async entry =>
{
    return await collection.UpsertAsync(entry);
}));

// 使用向量搜索在集合中搜索
var searchString = "What is Semantic Kernel?";
var searchVector = await textEmbeddingService.GenerateEmbeddingAsync(searchString);
var searchResults = await collection.SearchAsync(searchVector);
var resultRecord = await searchResults.FirstAsync();

Console.WriteLine($"Search result (score: {resultRecord.Score}): '{resultRecord.Record.Definition}'");
```

## 7. 创建提示并调用

[相关链接](https://aka.ms/sk/prompts)

使用提示模板与 Kernel 交互，可以动态地将参数和函数调用注入到提示中。

```
// 基本的提示调用
var result = await kernel.InvokePromptAsync("Tell me about GenAI");
Console.WriteLine(result.ToString());

// 带有函数调用的提示
result = await kernel.InvokePromptAsync("The current time is {{TimeInformation.GetCurrentUtcTime}}.");

// 带有参数的提示
KernelArguments arguments = new() { { "topic", "Dogs" } };
result = await kernel.InvokePromptAsync("Tell me about {{$topic}}", arguments);

// 带有执行设置的提示
OpenAIPromptExecutionSettings settings = new()
{
    FunctionChoiceBehavior = FunctionChoiceBehavior.Auto
};
result = await kernel.InvokePromptAsync("How long until Christmas? Explain your thinking.", new(settings));
```

## 8. 聊天补全

[相关链接](https://www.google.com/search?q=https://aka.ms/sk/chat)

`ChatCompletionService` 是与模型进行交互的常用方式，支持多轮对话和流式响应。

```
// ChatCompletionService 是与模型交互的常用方式
var chatService = kernel.GetRequiredService<IChatCompletionService>();
var chatHistory = new ChatHistory("You are a librarian, expert about books");

// 添加用户消息
chatHistory.AddUserMessage("Hi, I'm looking for book suggestions");

// 从服务获取响应
var reply = await chatService.GetChatMessageContentAsync(chatHistory);
chatHistory.Add(reply);

// 或者流式传输响应
await foreach (StreamingChatMessageContent chatUpdate in chatService.GetStreamingChatMessageContentsAsync(chatHistory))
{
    Console.Write(chatUpdate.Content);
}
```