# How to use Vector Stores with Semantic Kernel Text Search 如何将向量存储与Semantic Kernel文本搜索一起使用

- 10/16/2024

All of the Vector Store [connectors](https://learn.microsoft.com/en-us/semantic-kernel/concepts/vector-store-connectors/out-of-the-box-connectors/) can be used for text search.
所有矢量存储[连接器](https://learn.microsoft.com/en-us/semantic-kernel/concepts/vector-store-connectors/out-of-the-box-connectors/)都可用于文本搜索。

1. Use the Vector Store connector to retrieve the record collection you want to search.
   使用矢量存储连接器检索要搜索的记录集合。
2. Wrap the record collection with `VectorStoreTextSearch`.
   使用 `VectorStoreTextSearch` 包装记录集合。
3. Convert to a plugin for use in RAG and/or function calling scenarios.
   转换为插件，用于 RAG 和/或函数调用方案。

It's very likely that you will want to customize the plugin search function so that its description reflects the type of data available in the record collection. For example if the record collection contains information about hotels the plugin search function description should mention this. This will allow you to register multiple plugins e.g., one to search for hotels, another for restaurants and another for things to do.
您很可能想要自定义插件搜索功能，以便其描述反映记录集合中可用的数据类型。例如，如果记录集合包含有关酒店的信息，则插件搜索功能描述应提及这一点。这将允许您注册多个插件，例如，一个用于搜索酒店，另一个用于餐厅，另一个用于要做的事情。

The [text search abstractions](https://learn.microsoft.com/en-us/semantic-kernel/concepts/text-search/text-search-abstractions) include a function to return a normalized search result i.e., an instance of `TextSearchResult`. This normalized search result contains a value and optionally a name and link. The [text search abstractions](https://learn.microsoft.com/en-us/semantic-kernel/concepts/text-search/text-search-abstractions) include a function to return a string value e.g., one of the data model properties will be returned as the search result. For text search to work correctly you need to provide a way to map from the Vector Store data model to an instance of `TextSearchResult`. The next section describes the two options you can use to perform this mapping.
[文本搜索抽象](https://learn.microsoft.com/en-us/semantic-kernel/concepts/text-search/text-search-abstractions)包括一个返回规范化搜索结果的函数，即 `TextSearchResult` 的实例。此规范化搜索结果包含一个值，以及可选的名称和链接。[ 文本搜索抽象](https://learn.microsoft.com/en-us/semantic-kernel/concepts/text-search/text-search-abstractions)包括一个返回字符串值的函数，例如，将返回其中一个数据模型属性作为搜索结果。要使文本搜索正常工作，您需要提供一种从矢量存储数据模型映射到 `TextSearchResult` 实例的方法。下一节介绍可用于执行此映射的两个选项。

 Tip  提示

To run the samples shown on this page go to [GettingStartedWithTextSearch/Step4_Search_With_VectorStore.cs](https://github.com/microsoft/semantic-kernel/blob/main/dotnet/samples/GettingStartedWithTextSearch/Step4_Search_With_VectorStore.cs).
若要运行此页上显示的示例，请转到 [GettingStartedWithTextSearch/Step4_Search_With_VectorStore.cs](https://github.com/microsoft/semantic-kernel/blob/main/dotnet/samples/GettingStartedWithTextSearch/Step4_Search_With_VectorStore.cs)。



## Using a vector store model with text search 将矢量存储模型与文本搜索结合使用

The mapping from a Vector Store data model to a `TextSearchResult` can be done declaratively using attributes.
可以使用属性以声明方式完成从矢量存储数据模型到 `TextSearchResult` 的映射。

1. `[TextSearchResultValue]` - Add this attribute to the property of the data model which will be the value of the `TextSearchResult`, e.g. the textual data that the AI model will use to answer questions.
   `[TextSearchResultValue]` - 将此属性添加到数据模型的属性中，该属性将是 `TextSearchResult` 的值，例如 AI 模型将用于回答问题的文本数据。
2. `[TextSearchResultName]` - Add this attribute to the property of the data model which will be the name of the `TextSearchResult`.
   `[TextSearchResultName]` - 将此属性添加到数据模型的属性，该属性将成为 `TextSearchResult` 的名称。
3. `[TextSearchResultLink]` - Add this attribute to the property of the data model which will be the link to the `TextSearchResult`.
   `[TextSearchResultLink]` - 将此属性添加到数据模型的属性，该属性将成为`指向 TextSearchResult` 的链接。

The following sample shows an data model which has the text search result attributes applied.
以下示例显示了应用了文本搜索结果属性的数据模型。

C#Copy  复制

```csharp
using Microsoft.Extensions.VectorData;
using Microsoft.SemanticKernel.Data;

public sealed class DataModel
{
    [VectorStoreKey]
    [TextSearchResultName]
    public Guid Key { get; init; }

    [VectorStoreData]
    [TextSearchResultValue]
    public string Text { get; init; }

    [VectorStoreData]
    [TextSearchResultLink]
    public string Link { get; init; }

    [VectorStoreData(IsFilterable = true)]
    public required string Tag { get; init; }

    [VectorStoreVector(1536)]
    public ReadOnlyMemory<float> Embedding { get; init; }
}
```

The mapping from a Vector Store data model to a `string` or a `TextSearchResult` can also be done by providing implementations of `ITextSearchStringMapper` and `ITextSearchResultMapper` respectively.
还可以通过分别提供 `ITextSearchStringMapper` 和 `ITextSearchResultMapper` 的实现来完成从矢量存储数据模型到`字符串`或 `TextSearchResult` 的映射。

You may decide to create custom mappers for the following scenarios:
您可以决定为以下方案创建自定义映射器：

1. Multiple properties from the data model need to be combined together e.g., if multiple properties need to be combined to provide the value.
   数据模型中的多个属性需要组合在一起，例如，如果需要组合多个属性来提供值。
2. Additional logic is required to generate one of the properties e.g., if the link property needs to be computed from the data model properties.
   需要其他逻辑来生成其中一个属性，例如，如果需要从数据模型属性计算链接属性。

The following sample shows a data model and two example mapper implementations that can be used with the data model.
以下示例显示了一个数据模型和两个可与数据模型一起使用的映射器实现示例。

C#Copy  复制

```csharp
using Microsoft.Extensions.VectorData;
using Microsoft.SemanticKernel.Data;

protected sealed class DataModel
{
    [VectorStoreKey]
    public Guid Key { get; init; }

    [VectorStoreData]
    public required string Text { get; init; }

    [VectorStoreData]
    public required string Link { get; init; }

    [VectorStoreData(IsFilterable = true)]
    public required string Tag { get; init; }

    [VectorStoreVector(1536)]
    public ReadOnlyMemory<float> Embedding { get; init; }
}

/// <summary>
/// String mapper which converts a DataModel to a string.
/// </summary>
protected sealed class DataModelTextSearchStringMapper : ITextSearchStringMapper
{
    /// <inheritdoc />
    public string MapFromResultToString(object result)
    {
        if (result is DataModel dataModel)
        {
            return dataModel.Text;
        }
        throw new ArgumentException("Invalid result type.");
    }
}

/// <summary>
/// Result mapper which converts a DataModel to a TextSearchResult.
/// </summary>
protected sealed class DataModelTextSearchResultMapper : ITextSearchResultMapper
{
    /// <inheritdoc />
    public TextSearchResult MapFromResultToTextSearchResult(object result)
    {
        if (result is DataModel dataModel)
        {
            return new TextSearchResult(value: dataModel.Text) { Name = dataModel.Key.ToString(), Link = dataModel.Link };
        }
        throw new ArgumentException("Invalid result type.");
    }
}
```

The mapper implementations can be provided as parameters when creating the `VectorStoreTextSearch` as shown below:
创建 `VectorStoreTextSearch` 时，可以将映射器实现作为参数提供，如下所示：

C#Copy  复制

```csharp
using Microsoft.Extensions.VectorData;
using Microsoft.SemanticKernel.Data;

// Create custom mapper to map a <see cref="DataModel"/> to a <see cref="string"/>
var stringMapper = new DataModelTextSearchStringMapper();

// Create custom mapper to map a <see cref="DataModel"/> to a <see cref="TextSearchResult"/>
var resultMapper = new DataModelTextSearchResultMapper();

// Add code to create instances of VectorStoreCollection and ITextEmbeddingGenerationService 

// Create a text search instance using the vector store collection.
var result = new VectorStoreTextSearch<DataModel>(vectorStoreCollection, textEmbeddingGeneration, stringMapper, resultMapper);
```



## Using a vector store with text search 将矢量存储与文本搜索一起使用

The sample below shows how to create an instance of `VectorStoreTextSearch` using a Vector Store record collection.
下面的示例演示如何使用矢量存储记录集合创建 `VectorStoreTextSearch` 的实例。

 Tip  提示

The following samples require instances of `VectorStoreCollection` and `ITextEmbeddingGenerationService`. To create an instance of `VectorStoreCollection` refer to [the documentation for each connector](https://learn.microsoft.com/en-us/semantic-kernel/concepts/vector-store-connectors/out-of-the-box-connectors/). To create an instance of `ITextEmbeddingGenerationService` select the service you wish to use e.g., Azure OpenAI, OpenAI, ... or use a local model ONNX, Ollama, ... and create an instance of the corresponding `ITextEmbeddingGenerationService` implementation.
以下示例需要 `VectorStoreCollection` 和 `ITextEmbeddingGenerationService` 的实例。要创建 `VectorStoreCollection` 的实例，请参阅[每个连接器的文档 ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/vector-store-connectors/out-of-the-box-connectors/)。要创建要选择要使用的服务的 `ITextEmbeddingGenerationService` 实例，例如 Azure OpenAI、OpenAI、...或使用本地模型 ONNX、Ollama ......并创建相应 `ITextEmbeddingGenerationService` 实现的实例。

 Tip  提示

A `VectorStoreTextSearch` can also be constructed from an instance of `IVectorizableTextSearch`. In this case no `ITextEmbeddingGenerationService` is needed.
还可以从 `IVectorizableTextSearch` 的实例构造 `VectorStoreTextSearch`。在这种情况下，不需要。 `ITextEmbeddingGenerationService`

C#Copy  复制

```csharp
using Microsoft.Extensions.VectorData;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using Microsoft.SemanticKernel.Data;
using Microsoft.SemanticKernel.PromptTemplates.Handlebars;

// Add code to create instances of VectorStoreCollection and ITextEmbeddingGenerationService 

// Create a text search instance using the vector store collection.
var textSearch = new VectorStoreTextSearch<DataModel>(vectorStoreCollection, textEmbeddingGeneration);

// Search and return results as TextSearchResult items
var query = "What is the Semantic Kernel?";
KernelSearchResults<TextSearchResult> textResults = await textSearch.GetTextSearchResultsAsync(query, new() { Top = 2, Skip = 0 });
Console.WriteLine("\n--- Text Search Results ---\n");
await foreach (TextSearchResult result in textResults.Results)
{
    Console.WriteLine($"Name:  {result.Name}");
    Console.WriteLine($"Value: {result.Value}");
    Console.WriteLine($"Link:  {result.Link}");
}
```



## Creating a search plugin from a vector store 从矢量存储创建搜索插件

The sample below shows how to create a plugin named `SearchPlugin` from an instance of `VectorStoreTextSearch`. Using `CreateWithGetTextSearchResults` creates a new plugin with a single `GetTextSearchResults` function that calls the underlying Vector Store record collection search implementation. The `SearchPlugin` is added to the `Kernel` which makes it available to be called during prompt rendering. The prompt template includes a call to `{{SearchPlugin.Search $query}}` which will invoke the `SearchPlugin` to retrieve results related to the current query. The results are then inserted into the rendered prompt before it is sent to the model.
下面的示例展示了如何从 `VectorStoreTextSearch` 的实例创建名为 `SearchPlugin` 的插件。使用 `CreateWithGetTextSearchResults` 会创建一个新插件，其中包含一个 `GetTextSearchResults` 函数，该函数调用底层矢量存储记录集合搜索实现。`SearchPlugin` 被添加到`内核`中，使其可以在提示渲染期间调用。提示模板包括一个调用， `{{SearchPlugin.Search $query}}` 该调用将调用 `SearchPlugin` 来检索与当前查询相关的结果。然后，在将结果发送到模型之前，将结果插入渲染的提示中。

C#Copy  复制

```csharp
using Microsoft.Extensions.VectorData;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using Microsoft.SemanticKernel.Data;
using Microsoft.SemanticKernel.PromptTemplates.Handlebars;

// Create a kernel with OpenAI chat completion
IKernelBuilder kernelBuilder = Kernel.CreateBuilder();
kernelBuilder.AddOpenAIChatCompletion(
        modelId: TestConfiguration.OpenAI.ChatModelId,
        apiKey: TestConfiguration.OpenAI.ApiKey);
Kernel kernel = kernelBuilder.Build();

// Add code to create instances of VectorStoreCollection and ITextEmbeddingGenerationService

// Create a text search instance using the vector store collection.
var textSearch = new VectorStoreTextSearch<DataModel>(vectorStoreCollection, textEmbeddingGeneration);

// Build a text search plugin with vector store search and add to the kernel
var searchPlugin = textSearch.CreateWithGetTextSearchResults("SearchPlugin");
kernel.Plugins.Add(searchPlugin);

// Invoke prompt and use text search plugin to provide grounding information
var query = "What is the Semantic Kernel?";
string promptTemplate = """
    {{#with (SearchPlugin-GetTextSearchResults query)}}  
        {{#each this}}  
        Name: {{Name}}
        Value: {{Value}}
        Link: {{Link}}
        -----------------
        {{/each}}  
    {{/with}}  

    {{query}}

    Include citations to the relevant information where it is referenced in the response.
    """;
KernelArguments arguments = new() { { "query", query } };
HandlebarsPromptTemplateFactory promptTemplateFactory = new();
Console.WriteLine(await kernel.InvokePromptAsync(
    promptTemplate,
    arguments,
    templateFormat: HandlebarsPromptTemplateFactory.HandlebarsTemplateFormat,
    promptTemplateFactory: promptTemplateFactory
));
```



## Using a vector store with function calling 将向量存储与函数调用一起使用

The sample below also creates a `SearchPlugin` from an instance of `VectorStoreTextSearch`. This plugin will be advertised to the model for use with automatic function calling using the `FunctionChoiceBehavior` in the prompt execution settings. When you run this sample the model will invoke the search function to retrieve additional information to respond to the question. It will likely just search for "Semantic Kernel" rather than the entire query.
下面的示例还从 `VectorStoreTextSearch` 的实例创建了一个 `SearchPlugin`。此插件将通告给模型，以便使用提示执行设置中的 `FunctionChoiceBehavior` 进行自动函数调用。运行此示例时，模型将调用搜索函数来检索其他信息以响应问题。它可能只会搜索“Semantic Kernel”，而不是整个查询。

C#Copy  复制

```csharp
using Microsoft.Extensions.VectorData;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using Microsoft.SemanticKernel.Data;
using Microsoft.SemanticKernel.PromptTemplates.Handlebars;

// Create a kernel with OpenAI chat completion
IKernelBuilder kernelBuilder = Kernel.CreateBuilder();
kernelBuilder.AddOpenAIChatCompletion(
        modelId: TestConfiguration.OpenAI.ChatModelId,
        apiKey: TestConfiguration.OpenAI.ApiKey);
Kernel kernel = kernelBuilder.Build();

// Add code to create instances of VectorStoreCollection and ITextEmbeddingGenerationService

// Create a text search instance using the vector store collection.
var textSearch = new VectorStoreTextSearch<DataModel>(vectorStoreCollection, textEmbeddingGeneration);

// Build a text search plugin with vector store search and add to the kernel
var searchPlugin = textSearch.CreateWithGetTextSearchResults("SearchPlugin");
kernel.Plugins.Add(searchPlugin);

// Invoke prompt and use text search plugin to provide grounding information
OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto() };
KernelArguments arguments = new(settings);
Console.WriteLine(await kernel.InvokePromptAsync("What is the Semantic Kernel?", arguments));
```



## Customizing the search function 自定义搜索功能

The sample below how to customize the description of the search function that is added to the `SearchPlugin`. Some things you might want to do are:
下面的示例是如何自定义添加到 `SearchPlugin` 的搜索函数的描述。您可能想做的一些事情是：

1. Change the name of the search function to reflect what is in the associated record collection e.g., you might want to name the function `SearchForHotels` if the record collection contains hotel information.
   更改搜索函数的名称以反映关联记录集合中的内容，例如，如果记录集合包含酒店信息，则可能希望将函数命名为 `SearchForHotels`。
2. Change the description of the function. An accurate function description helps the AI model to select the best function to call. This is especially important if you are adding multiple search functions.
   更改函数的描述。准确的函数描述有助于 AI 模型选择要调用的最佳函数。如果您要添加多个搜索功能，这一点尤其重要。
3. Add an additional parameter to the search function. If the record collection contain hotel information and one of the properties is the city name you could add a property to the search function to specify the city. A filter will be automatically added and it will filter search results by city.
   向搜索函数添加一个附加参数。如果记录集合包含酒店信息，并且其中一个属性是城市名称，则可以将属性添加到搜索函数中以指定城市。系统会自动添加一个过滤器，并按城市过滤搜索结果。

 Tip  提示

The sample below uses the default implementation of search. You can opt to provide your own implementation which calls the underlying Vector Store record collection with additional options to fine tune your searches.
下面的示例使用搜索的默认实现。你可以选择提供自己的实现，该实现调用底层矢量存储记录集合，并提供其他选项来微调搜索。

C#Copy  复制

```csharp
using Microsoft.Extensions.VectorData;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using Microsoft.SemanticKernel.Data;
using Microsoft.SemanticKernel.PromptTemplates.Handlebars;

// Create a kernel with OpenAI chat completion
IKernelBuilder kernelBuilder = Kernel.CreateBuilder();
kernelBuilder.AddOpenAIChatCompletion(
        modelId: TestConfiguration.OpenAI.ChatModelId,
        apiKey: TestConfiguration.OpenAI.ApiKey);
Kernel kernel = kernelBuilder.Build();

// Add code to create instances of VectorStoreCollection and ITextEmbeddingGenerationService

// Create a text search instance using the vector store collection.
var textSearch = new VectorStoreTextSearch<DataModel>(vectorStoreCollection, textEmbeddingGeneration);

// Create options to describe the function I want to register.
var options = new KernelFunctionFromMethodOptions()
{
    FunctionName = "Search",
    Description = "Perform a search for content related to the specified query from a record collection.",
    Parameters =
    [
        new KernelParameterMetadata("query") { Description = "What to search for", IsRequired = true },
        new KernelParameterMetadata("top") { Description = "Number of results", IsRequired = false, DefaultValue = 2 },
        new KernelParameterMetadata("skip") { Description = "Number of results to skip", IsRequired = false, DefaultValue = 0 },
    ],
    ReturnParameter = new() { ParameterType = typeof(KernelSearchResults<string>) },
};

// Build a text search plugin with vector store search and add to the kernel
var searchPlugin = textSearch.CreateWithGetTextSearchResults("SearchPlugin", "Search a record collection", [textSearch.CreateSearch(options)]);
kernel.Plugins.Add(searchPlugin);

// Invoke prompt and use text search plugin to provide grounding information
OpenAIPromptExecutionSettings settings = new() { FunctionChoiceBehavior = FunctionChoiceBehavior.Auto() };
KernelArguments arguments = new(settings);
Console.WriteLine(await kernel.InvokePromptAsync("What is the Semantic Kernel?", arguments));
```



## Next steps  后续步骤

[  矢量存储](https://learn.microsoft.com/en-us/semantic-kernel/concepts/vector-store-connectors/)