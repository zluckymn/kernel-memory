# What is Semantic Kernel Text Search? 什么是Semantic Kernel文本搜索？

- 11/16/2024

The Semantic Kernel Text Search functionality is preview, and improvements that require breaking changes may still occur in limited circumstances before release.
Semantic Kernel文本搜索功能是预览版，在发布前的有限情况下，需要重大更改的改进仍可能发生。

Semantic Kernel provides capabilities that allow developers to integrate search when calling a Large Language Model (LLM). This is important because LLM's are trained on fixed data sets and may need access to additional data to accurately respond to a user ask.
Semantic Kernel提供的功能允许开发人员在调用大型语言模型 （LLM） 时集成搜索。这很重要，因为 LLM 是在固定数据集上训练的，可能需要访问其他数据才能准确响应用户的请求。

The process of providing additional context when prompting a LLM is called Retrieval-Augmented Generation (RAG). RAG typically involves retrieving additional data that is relevant to the current user ask and augmenting the prompt sent to the LLM with this data. The LLM can use its training plus the additional context to provide a more accurate response.
在提示 LLM 时提供额外上下文的过程称为检索增强生成 （RAG）。RAG 通常涉及检索与当前用户询问相关的其他数据，并使用此数据扩充发送到 LLM 的提示。LLM 可以使用其训练加上附加上下文来提供更准确的响应。

A simple example of when this becomes important is when the user's ask is related to up-to-date information not included in the LLM's training data set. By performing an appropriate text search and including the results with the user's ask, more accurate responses will be achieved.
当这变得重要时，一个简单的例子是当用户的询问与 LLM 训练数据集中未包含的最新信息相关时。通过执行适当的文本搜索并将结果与用户的询问一起包含在内，将获得更准确的响应。

Semantic Kernel provides a set of Text Search capabilities that allow developers to perform searches using Web Search or Vector Databases and easily add RAG to their applications.
Semantic Kernel提供了一组文本搜索功能，允许开发人员使用 Web 搜索或矢量数据库执行搜索，并轻松地将 RAG 添加到他们的应用程序中。



## How does text search differ from vector search? 文本搜索与矢量搜索有何不同？

Semantic Kernel provides APIs to perform data retrieval at different levels of abstraction.
Semantic Kernel提供了在不同抽象级别执行数据检索的 API。

Text search allows search at a high level in the stack, where the input is text with support for basic filtering. The text search interface supports various types of output, including support for just returning a simple string. This allows text search to support many implementations, including web search engines and vector stores. The main goal for text search is to provide a simple interface that can be exposed as a plugin to chat completion.
文本搜索允许在堆栈中进行高级搜索，其中输入是支持基本过滤的文本。文本搜索界面支持各种类型的输出，包括仅支持返回简单字符串。这使得文本搜索能够支持许多实现，包括 Web 搜索引擎和矢量存储。文本搜索的主要目标是提供一个简单的界面，可以作为聊天完成插件公开。

 Tip  提示

For all out-of-the-box text search implementations see [Out-of-the-box Text Search](https://learn.microsoft.com/en-us/semantic-kernel/concepts/text-search/out-of-the-box-textsearch/).
有关所有现成的文本搜索实现，请参阅现[成文本搜索 ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/text-search/out-of-the-box-textsearch/)。

Vector search sits at a lower level in the stack, where the input is a vector. It also supports basic filtering, plus choosing a vector from the data store to compare the input vector with. It returns a data model containing the data from the data store.
向量搜索位于堆栈的较低级别，其中输入是向量。它还支持基本过滤，以及从数据存储中选择一个向量来比较输入向量。它返回一个数据模型，其中包含来自数据存储的数据。

When you want to do RAG with Vector stores, it makes sense to use text search and vector search together. The way to to do this, is by wrapping a vector store collection, which supports vector search, with text search and then exposing the text search as a plugin to chat completion. Semantic Kernel provides the ability to do this easily out of the box. See the following tips for more information on how to do this.
当你想用矢量存储进行 RAG 时，同时使用文本搜索和矢量搜索是有意义的。执行此作的方法是将支持矢量搜索的矢量存储集合与文本搜索包装，然后将文本搜索公开为聊天完成插件。Semantic Kernel 提供了开箱即用的轻松执行此作的能力。有关如何执行此作的更多信息，请参阅以下提示。

 Tip  提示

To see how to expose vector search to chat completion see [How to use Vector Stores with Semantic Kernel Text Search](https://learn.microsoft.com/en-us/semantic-kernel/concepts/text-search/text-search-vector-stores).
若要了解如何将向量搜索公开到聊天完成，请参阅如何[将向量存储与Semantic Kernel文本搜索一起使用 ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/text-search/text-search-vector-stores)。

 Tip  提示

For more information on vector stores and vector search see [What are Semantic Kernel Vector Store connectors?](https://learn.microsoft.com/en-us/semantic-kernel/concepts/vector-store-connectors/).
有关向量存储和向量搜索的详细信息，请参阅[什么是Semantic Kernel向量存储连接器？](https://learn.microsoft.com/en-us/semantic-kernel/concepts/vector-store-connectors/)。



## Implementing RAG using web text search 使用 Web 文本搜索实现 RAG

In the following sample code you can choose between using Bing or Google to perform web search operations.
在以下示例代码中，可以选择使用 Bing 或 Google 来执行 Web 搜索作。

 Tip  提示

To run the samples shown on this page go to [GettingStartedWithTextSearch/Step1_Web_Search.cs](https://github.com/microsoft/semantic-kernel/blob/main/dotnet/samples/GettingStartedWithTextSearch/Step1_Web_Search.cs).
若要运行此页上显示的示例，请转到 [GettingStartedWithTextSearch/Step1_Web_Search.cs](https://github.com/microsoft/semantic-kernel/blob/main/dotnet/samples/GettingStartedWithTextSearch/Step1_Web_Search.cs)。



### Create text search instance 创建文本搜索实例

Each sample creates a text search instance and then performs a search operation to get results for the provided query. The search results will contain a snippet of text from the webpage that describes its contents. This provides only a limited context i.e., a subset of the web page contents and no link to the source of the information. Later samples show how to address these limitations.
每个示例都会创建一个文本搜索实例，然后执行搜索作以获取所提供查询的结果。搜索结果将包含网页中描述其内容的文本片段。这仅提供有限的上下文，即网页内容的子集，并且没有指向信息来源的链接。后面的示例演示如何解决这些限制。

 Tip  提示

The following sample code uses the Semantic Kernel OpenAI connector and Web plugins, install using the following commands:
以下示例代码使用Semantic Kernel OpenAI 连接器和 Web 插件，使用以下命令进行安装：

```
dotnet add package Microsoft.SemanticKernel`
`dotnet add package Microsoft.SemanticKernel.Plugins.Web
```



#### Bing web search  必应网络搜索

C#Copy  复制

```csharp
using Microsoft.SemanticKernel.Data;
using Microsoft.SemanticKernel.Plugins.Web.Bing;

// Create an ITextSearch instance using Bing search
var textSearch = new BingTextSearch(apiKey: "<Your Bing API Key>");

var query = "What is the Semantic Kernel?";

// Search and return results
KernelSearchResults<string> searchResults = await textSearch.SearchAsync(query, new() { Top = 4 });
await foreach (string result in searchResults.Results)
{
    Console.WriteLine(result);
}
```



#### Google web search  谷歌网络搜索

C#Copy  复制

```csharp
using Microsoft.SemanticKernel.Data;
using Microsoft.SemanticKernel.Plugins.Web.Google;

// Create an ITextSearch instance using Google search
var textSearch = new GoogleTextSearch(
    searchEngineId: "<Your Google Search Engine Id>",
    apiKey: "<Your Google API Key>");

var query = "What is the Semantic Kernel?";

// Search and return results
KernelSearchResults<string> searchResults = await textSearch.SearchAsync(query, new() { Top = 4 });
await foreach (string result in searchResults.Results)
{
    Console.WriteLine(result);
}
```

 Tip  提示

For more information on what types of search results can be retrieved, refer to [the documentation on Text Search Plugins](https://learn.microsoft.com/en-us/semantic-kernel/concepts/text-search/text-search-plugins).
有关可以检索哪些类型的搜索结果的更多信息，请参阅[有关文本搜索插件的文档 ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/text-search/text-search-plugins)。



### Use text search results to augment a prompt 使用文本搜索结果来扩充提示

Next steps are to create a Plugin from the web text search and invoke the Plugin to add the search results to the prompt.
接下来的步骤是从 Web 文本搜索创建一个插件，并调用该插件将搜索结果添加到提示中。

The sample code below shows how to achieve this:
下面的示例代码显示了如何实现这一点：

1. Create a `Kernel` that has an OpenAI service registered. This will be used to call the `gpt-4o` model with the prompt.
   创建注册了 OpenAI 服务的`内核 `。这将用于调用带有提示符的 `gpt-4o` 模型。
2. Create a text search instance.
   创建文本搜索实例。
3. Create a Search Plugin from the text search instance.
   从文本搜索实例创建搜索插件。
4. Create a prompt template that will invoke the Search Plugin with the query and include search results in the prompt along with the original query.
   创建一个提示模板，该模板将使用查询调用搜索插件，并将搜索结果与原始查询一起包含在提示中。
5. Invoke the prompt and display the response.
   调用提示并显示响应。

The model will provide a response that is grounded in the latest information available from a web search.
该模型将提供基于网络搜索中可用的最新信息的响应。



#### Bing web search  必应网络搜索

C#Copy  复制

```csharp
using Microsoft.SemanticKernel.Data;
using Microsoft.SemanticKernel.Plugins.Web.Bing;

// Create a kernel with OpenAI chat completion
IKernelBuilder kernelBuilder = Kernel.CreateBuilder();
kernelBuilder.AddOpenAIChatCompletion(
        modelId: "gpt-4o",
        apiKey: "<Your OpenAI API Key>");
Kernel kernel = kernelBuilder.Build();

// Create a text search using Bing search
var textSearch = new BingTextSearch(apiKey: "<Your Bing API Key>");

// Build a text search plugin with Bing search and add to the kernel
var searchPlugin = textSearch.CreateWithSearch("SearchPlugin");
kernel.Plugins.Add(searchPlugin);

// Invoke prompt and use text search plugin to provide grounding information
var query = "What is the Semantic Kernel?";
var prompt = "{{SearchPlugin.Search $query}}. {{$query}}";
KernelArguments arguments = new() { { "query", query } };
Console.WriteLine(await kernel.InvokePromptAsync(prompt, arguments));
```



#### Google web search  谷歌网络搜索

C#Copy  复制

```csharp
using Microsoft.SemanticKernel.Data;
using Microsoft.SemanticKernel.Plugins.Web.Google;

// Create a kernel with OpenAI chat completion
IKernelBuilder kernelBuilder = Kernel.CreateBuilder();
kernelBuilder.AddOpenAIChatCompletion(
        modelId: "gpt-4o",
        apiKey: "<Your OpenAI API Key>");
Kernel kernel = kernelBuilder.Build();

// Create an ITextSearch instance using Google search
var textSearch = new GoogleTextSearch(
    searchEngineId: "<Your Google Search Engine Id>",
    apiKey: "<Your Google API Key>");

// Build a text search plugin with Google search and add to the kernel
var searchPlugin = textSearch.CreateWithSearch("SearchPlugin");
kernel.Plugins.Add(searchPlugin);

// Invoke prompt and use text search plugin to provide grounding information
var query = "What is the Semantic Kernel?";
var prompt = "{{SearchPlugin.Search $query}}. {{$query}}";
KernelArguments arguments = new() { { "query", query } };
Console.WriteLine(await kernel.InvokePromptAsync(prompt, arguments));
```

There are a number of issues with the above sample:
上述示例存在许多问题：

1. The response does not include citations showing the web pages that were used to provide grounding context.
   该回复不包括显示用于提供基础上下文的网页的引文。
2. The response will include data from any web site, it would be better to limit this to trusted sites.
   响应将包括来自任何网站的数据，最好将其限制为受信任的站点。
3. Only a snippet of each web page is being used to provide grounding context to the model, the snippet may not contain the data required to provide an accurate response.
   仅使用每个网页的一个片段为模型提供基础上下文，该片段可能不包含提供准确响应所需的数据。

See the page which describes [Text Search Plugins](https://learn.microsoft.com/en-us/semantic-kernel/concepts/text-search/text-search-plugins) for solutions to these issues.
请参阅描述[文本搜索插件](https://learn.microsoft.com/en-us/semantic-kernel/concepts/text-search/text-search-plugins)的页面，了解这些问题的解决方案。

Next we recommend looking at [Text Search Abstractions](https://learn.microsoft.com/en-us/semantic-kernel/concepts/text-search/text-search-abstractions).
接下来，我们建议查看[文本搜索抽象 ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/text-search/text-search-abstractions)。



## Next steps  后续步骤


抽象 