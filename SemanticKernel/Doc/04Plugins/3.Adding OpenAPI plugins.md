# Add plugins from OpenAPI specifications 从 OpenAPI 规范添加插件

- 04/04/2025

Often in an enterprise, you already have a set of APIs that perform real work. These could be used by other automation services or power front-end applications that humans interact with. In Semantic Kernel, you can add these exact same APIs as plugins so your agents can also use them.
通常在企业中，您已经拥有一组执行实际工作的 API。这些可以由其他自动化服务或为人类交互的前端应用程序提供动力。在Semantic Kernel中，您可以将这些完全相同的 API 添加为插件，以便您的代理也可以使用它们。



## An example OpenAPI specification OpenAPI 规范示例

Take for example an API that allows you to alter the state of light bulbs. The OpenAPI specification, known as Swagger Specification, or just Swagger, for this API might look like this:
以允许您更改灯泡状态的 API 为例。此 API 的 OpenAPI 规范（称为 Swagger 规范或简称为 Swagger）可能如下所示：

JSONCopy  复制

```json
{
   "openapi": "3.0.1",
   "info": {
      "title": "Light API",
      "version": "v1"
   },
   "paths": {
      "/Light": {
         "get": {
            "summary": "Retrieves all lights in the system.",
            "operationId": "get_all_lights",
            "responses": {
               "200": {
                  "description": "Returns a list of lights with their current state",
                  "application/json": {
                     "schema": {
                        "type": "array",
                        "items": {
                              "$ref": "#/components/schemas/LightStateModel"
                        }
                     }
                  }
               }
            }
         }
      },
      "/Light/{id}": {
         "post": {
               "summary": "Changes the state of a light.",
               "operationId": "change_light_state",
               "parameters": [
                  {
                     "name": "id",
                     "in": "path",
                     "description": "The ID of the light to change.",
                     "required": true,
                     "style": "simple",
                     "schema": {
                           "type": "string"
                     }
                  }
               ],
               "requestBody": {
                  "description": "The new state of the light and change parameters.",
                  "content": {
                     "application/json": {
                           "schema": {
                              "$ref": "#/components/schemas/ChangeStateRequest"
                           }
                     }
                  }
               },
               "responses": {
                  "200": {
                     "description": "Returns the updated light state",
                     "content": {
                           "application/json": {
                              "schema": {
                                 "$ref": "#/components/schemas/LightStateModel"
                              }
                           }
                     }
                  },
                  "404": {
                     "description": "If the light is not found"
                  }
               }
         }
      }
   },
   "components": {
      "schemas": {
         "ChangeStateRequest": {
               "type": "object",
               "properties": {
                  "isOn": {
                     "type": "boolean",
                     "description": "Specifies whether the light is turned on or off.",
                     "nullable": true
                  },
                  "hexColor": {
                     "type": "string",
                     "description": "The hex color code for the light.",
                     "nullable": true
                  },
                  "brightness": {
                     "type": "integer",
                     "description": "The brightness level of the light.",
                     "format": "int32",
                     "nullable": true
                  },
                  "fadeDurationInMilliseconds": {
                     "type": "integer",
                     "description": "Duration for the light to fade to the new state, in milliseconds.",
                     "format": "int32",
                     "nullable": true
                  },
                  "scheduledTime": {
                     "type": "string",
                     "description": "Use ScheduledTime to synchronize lights. It's recommended that you asynchronously create tasks for each light that's scheduled to avoid blocking the main thread.",
                     "format": "date-time",
                     "nullable": true
                  }
               },
               "additionalProperties": false,
               "description": "Represents a request to change the state of the light."
         },
         "LightStateModel": {
               "type": "object",
               "properties": {
                  "id": {
                     "type": "string",
                     "nullable": true
                  },
                  "name": {
                     "type": "string",
                     "nullable": true
                  },
                  "on": {
                     "type": "boolean",
                     "nullable": true
                  },
                  "brightness": {
                     "type": "integer",
                     "format": "int32",
                     "nullable": true
                  },
                  "hexColor": {
                     "type": "string",
                     "nullable": true
                  }
               },
               "additionalProperties": false
         }
      }
   }
}
```

This specification provides everything needed by the AI to understand the API and how to interact with it. The API includes two endpoints: one to get all lights and another to change the state of a light. It also provides the following:
该规范提供了 AI 理解 API 以及如何与其交互所需的一切。该 API 包括两个端点：一个用于获取所有灯源，另一个用于更改灯源的状态。它还提供以下内容：

- Semantic descriptions for the endpoints and their parameters
  端点及其参数的语义描述
- The types of the parameters
  参数的类型
- The expected responses  预期的回应

Since the AI agent can understand this specification, you can add it as a plugin to the agent.
由于 AI 代理可以理解此规范，因此您可以将其作为插件添加到代理中。

Semantic Kernel supports OpenAPI versions 2.0 and 3.0, and it aims to accommodate version 3.1 specifications by downgrading it to version 3.0.
Semantic Kernel 支持 OpenAPI 2.0 和 3.0 版本，旨在通过将其降级到 3.0 版本来适应 3.1 版本规范。

 Tip  提示

If you have existing OpenAPI specifications, you may need to make alterations to make them easier for an AI to understand them. For example, you may need to provide guidance in the descriptions. For more tips on how to make your OpenAPI specifications AI-friendly, see [Tips and tricks for adding OpenAPI plugins](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins?pivots=programming-language-csharp#tips-and-tricks-for-adding-openapi-plugins).
如果您有现有的 OpenAPI 规范，您可能需要进行更改以使 AI 更容易理解它们。例如，您可能需要在说明中提供指导。有关如何使 OpenAPI 规范对 AI 友好的更多提示，请参阅[添加 OpenAPI 插件的提示和技巧 ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins?pivots=programming-language-csharp#tips-and-tricks-for-adding-openapi-plugins)。



## Adding the OpenAPI plugin 添加 OpenAPI 插件

With a few lines of code, you can add the OpenAPI plugin to your agent. The following code snippet shows how to add the light plugin from the OpenAPI specification above:
只需几行代码，您就可以将 OpenAPI 插件添加到您的代理中。以下代码片段显示了如何从上面的 OpenAPI 规范中添加轻量级插件：

C#Copy  复制

```csharp
await kernel.ImportPluginFromOpenApiAsync(
   pluginName: "lights",
   uri: new Uri("https://example.com/v1/swagger.json"),
   executionParameters: new OpenApiFunctionExecutionParameters()
   {
      // Determines whether payload parameter names are augmented with namespaces.
      // Namespaces prevent naming conflicts by adding the parent parameter name
      // as a prefix, separated by dots
      EnablePayloadNamespacing = true
   }
);
```

With Semantic Kernel, you can add OpenAPI plugins from various sources, such as a URL, file, or stream. Additionally, plugins can be created once and reused across multiple kernel instances or agents.
使用Semantic Kernel，您可以从各种来源（例如 URL、文件或流）添加 OpenAPI 插件。此外，插件可以创建一次，并在多个内核实例或代理中重复使用。

C#Copy  复制

```csharp
// Create the OpenAPI plugin from a local file somewhere at the root of the application
KernelPlugin plugin = await OpenApiKernelPluginFactory.CreateFromOpenApiAsync(
    pluginName: "lights",
    filePath: "path/to/lights.json"
);

// Add the plugin to the kernel
Kernel kernel = new Kernel();
kernel.Plugins.Add(plugin);
```

Afterwards, you can use the plugin in your agent as if it were a native plugin.
之后，您可以在代理中使用该插件，就像它是本机插件一样。



## Handling OpenAPI plugin parameters 处理 OpenAPI 插件参数

Semantic Kernel automatically extracts metadata - such as name, description, type, and schema for all parameters defined in OpenAPI documents. This metadata is stored in the `KernelFunction.Metadata.Parameters` property for each OpenAPI operation and is provided to the LLM along with the prompt to generate the correct arguments for function calls.
Semantic Kernel会自动提取元数据，例如 OpenAPI 文档中定义的所有参数的名称、描述、类型和模式。此元数据存储在每个 OpenAPI 作的 `KernelFunction.Metadata.Parameters` 属性中，并与提示一起提供给 LLM，以生成函数调用的正确参数。

By default, the original parameter name is provided to the LLM and is used by Semantic Kernel to look up the corresponding argument in the list of arguments supplied by the LLM. However, there may be cases where the OpenAPI plugin has multiple parameters with the same name. Providing this parameter metadata to the LLM could create confusion, potentially preventing the LLM from generating the correct arguments for function calls.
默认情况下，原始参数名称提供给 LLM，并由Semantic Kernel用于在 LLM 提供的参数列表中查找相应的参数。但是，在某些情况下，OpenAPI 插件可能具有多个同名的参数。向 LLM 提供此参数元数据可能会造成混乱，从而可能阻止 LLM 为函数调用生成正确的参数。

Additionally, since a kernel function that does not allow for non-unique parameter names is created for each OpenAPI operation, adding such a plugin could result in some operations becoming unavailable for use. Specifically, operations with non-unique parameter names will be skipped, and a corresponding warning will be logged. Even if it were possible to include multiple parameters with the same name in the kernel function, this could lead to ambiguity in the argument selection process.
此外，由于为每个 OpenAPI 作创建了一个不允许非唯一参数名称的内核函数，因此添加此类插件可能会导致某些作变得无法使用。具体来说，将跳过具有非唯一参数名称的作，并记录相应的警告。即使可以在内核函数中包含多个同名参数，这也可能导致参数选择过程中的歧义。

Considering all of this, Semantic Kernel offers a solution for managing plugins with non-unique parameter names. This solution is particularly useful when changing the API itself is not feasible, whether due to it being a third-party service or a legacy system.
考虑到所有这些，Semantic Kernel提供了一种管理具有非唯一参数名称的插件的解决方案。当更改 API 本身不可行时，无论是由于它是第三方服务还是遗留系统，此解决方案都特别有用。

The following code snippet demonstrates how to handle non-unique parameter names in an OpenAPI plugin. If the change_light_state operation had an additional parameter with the same name as the existing "id" parameter - specifically, to represent a session ID in addition to the current "id" that represents the ID of the light - it could be handled as shown below:
以下代码片段演示了如何在 OpenAPI 插件中处理非唯一参数名称。如果 change_light_state 作有一个与现有“id”参数同名的附加参数（具体来说，除了表示灯光 ID 的当前“id”之外，还表示会话 ID），则可以按如下所示进行处理：

C#Copy  复制

```csharp
OpenApiDocumentParser parser = new();

using FileStream stream = File.OpenRead("path/to/lights.json");

// Parse the OpenAPI document
RestApiSpecification specification = await parser.ParseAsync(stream);

// Get the change_light_state operation
RestApiOperation operation = specification.Operations.Single(o => o.Id == "change_light_state");

// Set the 'lightId' argument name to the 'id' path parameter that represents the ID of the light
RestApiParameter idPathParameter = operation.Parameters.Single(p => p.Location == RestApiParameterLocation.Path && p.Name == "id");
idPathParameter.ArgumentName = "lightId";

// Set the 'sessionId' argument name to the 'id' header parameter that represents the session ID
RestApiParameter idHeaderParameter = operation.Parameters.Single(p => p.Location == RestApiParameterLocation.Header && p.Name == "id");
idHeaderParameter.ArgumentName = "sessionId";

// Import the transformed OpenAPI plugin specification
kernel.ImportPluginFromOpenApi(pluginName: "lights", specification: specification);
```

This code snippet utilizes the `OpenApiDocumentParser` class to parse the OpenAPI document and access the `RestApiSpecification` model object that represents the document. It assigns argument names to the parameters and imports the transformed OpenAPI plugin specification into the kernel. Semantic Kernel provides the argument names to the LLM instead of the original names and uses them to look up the corresponding arguments in the list supplied by the LLM.
此代码片段利用 `OpenApiDocumentParser` 类来解析 OpenAPI 文档并访问表示该文档的 `RestApiSpecification` 模型对象。它为参数分配参数名称，并将转换后的 OpenAPI 插件规范导入内核。Semantic Kernel向 LLM 提供参数名称而不是原始名称，并使用它们在 LLM 提供的列表中查找相应的参数。

It is important to note that the argument names are not used in place of the original names when calling the OpenAPI operation. In the example above, the 'id' parameter in the path will be replaced by a value returned by the LLM for the 'lightId' argument. The same applies to the 'id' header parameter; the value returned by the LLM for the 'sessionId' argument will be used as the value for the header named 'id'.
请务必注意，在调用 OpenAPI 作时，不会使用参数名称代替原始名称。在上面的示例中，路径中的“id”参数将替换为 LLM 为“lightId”参数返回的值。这同样适用于 'id' 标头参数;LLM 为“sessionId”参数返回的值将用作名为“id”的标头的值。



## Handling OpenAPI plugins payload 处理 OpenAPI 插件有效负载

OpenAPI plugins can modify the state of the system using POST, PUT, or PATCH operations. These operations often require a payload to be included with the request.
OpenAPI 插件可以使用 POST、PUT 或 PATCH 作修改系统状态。这些作通常需要将有效负载包含在请求中。

Semantic Kernel offers a few options for managing payload handling for OpenAPI plugins, depending on your specific scenario and API requirements.
Semantic Kernel提供了一些选项来管理 OpenAPI 插件的有效负载处理，具体取决于您的具体场景和 API 要求。



### Dynamic payload construction 动态有效载荷结构

Dynamic payload construction allows the payloads of OpenAPI operations to be created dynamically based on the payload schema and arguments provided by the LLM. This feature is enabled by default but can be disabled by setting the `EnableDynamicPayload` property to `false` in the `OpenApiFunctionExecutionParameters` object when adding an OpenAPI plugin.
动态有效负载构造允许根据 LLM 提供的有效负载模式和参数动态创建 OpenAPI 作的有效负载。默认情况下，此功能处于启用状态，但可以通过在添加 OpenAPI 插件时将 `OpenApiFunctionExecutionParameters` 对象中的 `EnableDynamicPayload` 属性设置为 `false` 来禁用此功能。

For example, consider the change_light_state operation, which requires a payload structured as follows:
例如，考虑 change_light_state 作，它需要结构如下的有效负载：

JSONCopy  复制

```json
{
   "isOn": true,
   "hexColor": "#FF0000",
   "brightness": 100,
   "fadeDurationInMilliseconds": 500,
   "scheduledTime": "2023-07-12T12:00:00Z"
}
```

To change the state of the light and get values for the payload properties, Semantic Kernel provides the LLM with metadata for the operation so it can reason about it:
为了更改灯光的状态并获取有效负载属性的值，Semantic Kernel为 LLM 提供了作的元数据，以便它可以对其进行推理：

JSONCopy  复制

```json
{
    "name":"lights-change-light-state",
    "description": "Changes the state of a light.",
    "parameters":[
        { "name": "id", "schema": {"type":"string", "description": "The ID of the light to change.", "format":"uuid"}},
        { "name": "isOn", "schema": { "type": "boolean", "description": "Specifies whether the light is turned on or off."}},
        { "name": "hexColor", "schema": { "type": "string", "description": "Specifies whether the light is turned on or off."}},
        { "name": "brightness", "schema": { "type":"string", "description":"The brightness level of the light.", "enum":["Low","Medium","High"]}},
        { "name": "fadeDurationInMilliseconds", "schema": { "type":"integer", "description":"Duration for the light to fade to the new state, in milliseconds.", "format":"int32"}},
        { "name": "scheduledTime", "schema": {"type":"string", "description":"The time at which the change should occur.", "format":"date-time"}},
    ]
}
```

In addition to providing operation metadata to the LLM, Semantic Kernel will perform the following steps:
除了向 LLM 提供作元数据外，Semantic Kernel还将执行以下步骤：

1. Handle the LLM call to the OpenAPI operation, constructing the payload based on the schema and provided by LLM property values.
   处理对 OpenAPI 作的 LLM 调用，根据架构构造有效负载，并由 LLM 属性值提供。
2. Send the HTTP request with the payload to the API.
   将带有有效负载的 HTTP 请求发送到 API。



#### Limitations of dynamic payload construction 动态有效载荷构建的局限性

Dynamic payload construction is most effective for APIs with relatively simple payload structures. It may not be reliably work or work at all, for APIs payloads exhibiting the following characteristics:
动态有效负载构建对于有效负载结构相对简单的 API 最有效。对于表现出以下特征的 API 有效负载，它可能无法可靠地工作或根本无法工作：

- Payloads with non-unique property names regardless of the location of the properties. E.g., two properties named `id`, one for sender object and another for receiver object - `json { "sender": { "id": ... }, "receiver": { "id": ... }}`
  具有非唯一属性名称的有效负载，无论属性的位置如何。例如，两个名为 `id` 的属性，一个用于发送方对象，另一个用于接收方对象 - `json { "sender": { "id": ... }, "receiver": { "id": ... }}`
- Payload schemas that use any of the composite keywords `oneOf`, `anyOf`, `allOf`.
  使用任何复合关键字 `oneOf`、`anyOf`、`allOf` 的有效负载架构。
- Payload schemas with recursive references. E.g., `json { "parent": { "child": { "$ref": "#parent" } } }`
  具有递归引用的有效负载架构。例如， `json { "parent": { "child": { "$ref": "#parent" } } }`

To handle payloads with non-unique property names, consider the following alternatives:
要处理具有非唯一属性名称的有效负载，请考虑以下替代方法：

- Provide a unique argument name for each non-unique property, using a method similar to that described in the [Handling OpenAPI plugin parameters](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins#handling-openapi-plugin-parameters) section.
  为每个非唯一属性提供唯一的参数名称，使用类似于[处理 OpenAPI 插件参数](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins#handling-openapi-plugin-parameters)部分中描述的方法。
- Use namespaces to avoid naming conflicts, as outlined in the next section on [Payload namespacing](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins#payload-namespacing).
  使用命名空间避免命名冲突，如下一节有关[有效负载命名空间](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins#payload-namespacing)的概述。
- Disable dynamic payload construction and allow the LLM to create the payload based on its schema, as explained in the [The payload parameter](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins#the-payload-parameter) section.
  禁用动态有效负载构造，并允许 LLM 根据其架构创建有效负载，如[有效负载参数](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins#the-payload-parameter)部分所述。

If payloads schemas use any of the `oneOf`, `anyOf`, `allOf` composite keywords or recursive references, consider disabling dynamic payload construction and allow the LLM to create the payload based on its schema, as explained in the [The payload parameter](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins#the-payload-parameter) section.
如果有效负载架构使用任何 `oneOf`、`anyOf`、`allOf` 复合关键字或递归引用，请考虑禁用动态有效负载构造，并允许 LLM 根据其架构创建有效负载，如[有效负载参数](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins#the-payload-parameter)部分中所述。



#### Note on the `oneOf` and `anyOf` Keywords 关于 `oneOf` 和 `anyOf` 关键字的注意事项

The `anyOf` and `oneOf` keywords assume that a payload can be composed of properties defined by multiple schemas. The `anyOf` keyword allows a payload to include properties defined in one or more schemas, while `oneOf` restricts the payload to contain properties from only one schema among the many provided. For more information, you can refer to the [Swagger documentation on oneOf and anyOf](https://swagger.io/docs/specification/v3_0/data-models/oneof-anyof-allof-not/).
`anyOf` 和 `oneOf` 关键字假定有效负载可以由多个架构定义的属性组成。`anyOf` 关键字允许有效负载包含一个或多个架构中定义的属性，而 `oneOf` 将有效负载限制为仅包含提供的众多架构中一个架构的属性。有关更多信息，您可以参考 [Swagger 文档中关于 oneOf 和 anyOf 的文档 ](https://swagger.io/docs/specification/v3_0/data-models/oneof-anyof-allof-not/)。

With both `anyOf` and `oneOf` keywords, which offer alternatives to the payload structure, it's impossible to predict which alternative a caller will choose when invoking operations that define payloads with these keywords. For example, it is not possible to determine in advance whether a caller will invoke an operation with a Dog or Cat object, or with an object composed of some or perhaps all properties from the PetByAge and PetByType schemas described in the examples for `anyOf` and `oneOf` in the [Swagger documentation](https://swagger.io/docs/specification/v3_0/data-models/oneof-anyof-allof-not/). As a result, because there's no set of parameters known in advance that Semantic Kernel can use to create the a plugin function with for such operations, Semantic Kernel creates a function with only one [payload](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins#the-payload-parameter) parameter having a schema from the operation describing a multitude of possible alternatives, offloading the payload creation to the operation caller: LLM or calling code that must have all the context to know which one of the available alternatives to invoke the function with.
对于 `anyOf` 和 `oneOf` 关键字，它们都提供了有效负载结构的替代项，因此无法预测调用方在调用使用这些关键字定义有效负载的作时将选择哪种替代项。例如，无法预先确定调用方是否会使用 Dog 或 Cat 对象调用作，或者调用由 PetByAge 和 PetByType 架构中的部分或全部属性组成的对象，这些属性在 [Swagger 文档](https://swagger.io/docs/specification/v3_0/data-models/oneof-anyof-allof-not/)中的 `anyOf` 和 `oneOf` 示例中所述。因此，由于Semantic Kernel没有预先知道的一组参数可用于为此类作创建插件函数，因此Semantic Kernel创建一个函数，该函数只有一个[有效负载](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins#the-payload-parameter)参数，该参数具有描述多种可能备选方案的作的架构，从而将有效负载创建卸载给作调用方： LLM 或调用代码，必须具有所有上下文才能知道使用哪一种可用的替代方法来调用函数。



### Payload namespacing  有效负载命名空间

Payload namespacing helps prevent naming conflicts that can occur due to non-unique property names in OpenAPI plugin payloads.
有效负载命名空间有助于防止由于 OpenAPI 插件有效负载中的非唯一属性名称而可能发生的命名冲突。

When namespacing is enabled, Semantic Kernel provides the LLM with OpenAPI operation metadata that includes augmented property names. These augmented names are created by adding the parent property name as a prefix, separated by a dot, to the child property names.
启用命名空间后，Semantic Kernel会为 LLM 提供包含增强属性名称的 OpenAPI 作元数据。这些增强名称是通过将父属性名称作为前缀（用点分隔）添加到子属性名称中来创建的。

For example, if the change_light_state operation had included a nested `offTimer` object with a `scheduledTime` property:
例如，如果 change_light_state 作包含具有 `scheduledTime` 属性的嵌套 `offTimer` 对象：

JSONCopy  复制

```json
{
  "isOn": true,
  "hexColor": "#FF0000",
  "brightness": 100,
  "fadeDurationInMilliseconds": 500,
  "scheduledTime": "2023-07-12T12:00:00Z",
  "offTimer": {
      "scheduledTime": "2023-07-12T12:00:00Z"
  }
}
```

Semantic Kernel would have provided the LLM with metadata for the operation that includes the following property names:
Semantic Kernel会为 LLM 提供作的元数据，其中包括以下属性名称：

JSONCopy  复制

```json
{
    "name":"lights-change-light-state",
    "description": "Changes the state of a light.",
    "parameters":[
        { "name": "id", "schema": {"type":"string", "description": "The ID of the light to change.", "format":"uuid"}},
        { "name": "isOn", "schema": { "type": "boolean", "description": "Specifies whether the light is turned on or off."}},
        { "name": "hexColor", "schema": { "type": "string", "description": "Specifies whether the light is turned on or off."}},
        { "name": "brightness", "schema": { "type":"string", "description":"The brightness level of the light.", "enum":["Low","Medium","High"]}},
        { "name": "fadeDurationInMilliseconds", "schema": { "type":"integer", "description":"Duration for the light to fade to the new state, in milliseconds.", "format":"int32"}},
        { "name": "scheduledTime", "schema": {"type":"string", "description":"The time at which the change should occur.", "format":"date-time"}},
        { "name": "offTimer.scheduledTime", "schema": {"type":"string", "description":"The time at which the device will be turned off.", "format":"date-time"}},
    ]
}
```

In addition to providing operation metadata with augmented property names to the LLM, Semantic Kernel performs the following steps:
除了向 LLM 提供带有增强属性名称的作元数据外，Semantic Kernel还执行以下步骤：

1. Handle the LLM call to the OpenAPI operation and look up the corresponding arguments among those provided by the LLM for all the properties in the payload, using the augmented property names and falling back to the original property names if necessary.
   处理对 OpenAPI 作的 LLM 调用，并在 LLM 为有效负载中的所有属性提供的参数中查找相应的参数，使用增强的属性名称，并在必要时回退到原始属性名称。
2. Construct the payload using the original property names as keys and the resolved arguments as values.
   使用原始属性名称作为键，将解析的参数作为值来构造有效负载。
3. Send the HTTP request with the constructed payload to the API.
   将带有构造有效负载的 HTTP 请求发送到 API。

By default, the payload namespacing option is disabled. It can be enabled by setting the `EnablePayloadNamespacing` property to `true` in the `OpenApiFunctionExecutionParameters` object when adding an OpenAPI plugin:
默认情况下，有效负载命名空间选项处于禁用状态。添加 OpenAPI 插件时，可以通过在 `OpenApiFunctionExecutionParameters` 对象中将 `EnablePayloadNamespacing` 属性设置为 `true` 来启用它：

C#Copy  复制

```csharp
await kernel.ImportPluginFromOpenApiAsync(
    pluginName: "lights",
    uri: new Uri("https://example.com/v1/swagger.json"),
    executionParameters: new OpenApiFunctionExecutionParameters()
    {
        EnableDynamicPayload = true, // Enable dynamic payload construction. This is enabled by default.
        EnablePayloadNamespacing = true // Enable payload namespacing
    });
```

 Note  注意

The `EnablePayloadNamespace` option only takes effect when dynamic payload construction is also enabled; otherwise, it has no effect.
`EnablePayloadNamespace` 选项仅在同时启用动态有效负载构造时生效;否则，它没有效果。



### The payload parameter  有效负载参数

Semantic Kernel can work with payloads created by the LLM using the payload parameter. This is useful when the payload schema is complex and contains non-unique property names, which makes it infeasible for Semantic Kernel to dynamically construct the payload. In such cases, you will be relying on the LLM's ability to understand the schema and construct a valid payload. Recent models, such as `gpt-4o` are effective at generating valid JSON payloads.
Semantic Kernel可以使用有效负载参数处理 LLM 创建的有效负载。当有效负载架构复杂且包含非唯一属性名称时，这非常有用，这使得Semantic Kernel无法动态构造有效负载。在这种情况下，您将依赖 LLM 理解架构和构造有效有效负载的能力。最近的模型，例如 `gpt-4o` 可以有效地生成有效的 JSON 有效负载。

To enable the payload parameter, set the `EnableDynamicPayload` property to `false` in the `OpenApiFunctionExecutionParameters` object when adding an OpenAPI plugin:
要启用有效负载参数，请在添加 OpenAPI 插件时将 `OpenApiFunctionExecutionParameters` 对象中的 `EnableDynamicPayload` 属性设置为 `false`：

C#Copy  复制

```csharp
await kernel.ImportPluginFromOpenApiAsync(
    pluginName: "lights",
    uri: new Uri("https://example.com/v1/swagger.json"),
    executionParameters: new OpenApiFunctionExecutionParameters()
    {
        EnableDynamicPayload = false, // Disable dynamic payload construction
    });
```

When the payload parameter is enabled, Semantic Kernel provides the LLM with metadata for the operation that includes schemas for the payload and content_type parameters, allowing the LLM to understand the payload structure and construct it accordingly:
启用有效负载参数后，Semantic Kernel会向 LLM 提供作的元数据，其中包括有效负载的架构和 content_type 参数，从而允许 LLM 了解有效负载结构并相应地构造它：

JSONCopy  复制

```json
{
    "name": "payload",
    "schema":
    {
        "type": "object",
        "properties": {
            "isOn": {
                "type": "boolean",
                "description": "Specifies whether the light is turned on or off."
            },
            "hexColor": {
                "type": "string",
                "description": "The hex color code for the light.",
            },
            "brightness": {
                "enum": ["Low", "Medium", "High"],
                "type": "string",
                "description": "The brightness level of the light."
            },
            "fadeDurationInMilliseconds": {
                "type": "integer",
                "description": "Duration for the light to fade to the new state, in milliseconds.",
                "format": "int32"
            },
            "scheduledTime": {
                "type": "string",
                "description": "The time at which the change should occur.",
                "format": "date-time"
            }
        },
        "additionalProperties": false,
        "description": "Represents a request to change the state of the light."
    },
    {
        "name": "content_type",
        "schema":
        {
            "type": "string",
            "description": "Content type of REST API request body."
        }
    }
}
```

In addition to providing the operation metadata with the schema for payload and content type parameters to the LLM, Semantic Kernel performs the following steps:
除了向 LLM 提供作元数据以及有效负载和内容类型参数的架构外，Semantic Kernel还执行以下步骤：

1. Handle the LLM call to the OpenAPI operation and uses arguments provided by the LLM for the payload and content_type parameters.
   处理对 OpenAPI 作的 LLM 调用，并使用 LLM 为有效负载和 content_type 参数提供的参数。
2. Send the HTTP request to the API with provided payload and content type.
   将 HTTP 请求发送到具有提供的有效负载和内容类型的 API。



## Server base url  服务器基本网址

Semantic Kernel OpenAPI plugins require a base URL, which is used to prepend endpoint paths when making API requests. This base URL can be specified in the OpenAPI document, obtained implicitly by loading the document from a URL, or provided when adding the plugin to the kernel.
Semantic Kernel OpenAPI 插件需要一个基本 URL，用于在发出 API 请求时在端点路径前面添加该 URL。此基本 URL 可以在 OpenAPI 文档中指定，通过从 URL 加载文档隐式获取，或在将插件添加到内核时提供。



### Url specified in OpenAPI document OpenAPI 文档中指定的 URL

OpenAPI v2 documents define the server URL using the `schemes`, `host`, and `basePath` fields:
OpenAPI v2 文档使用 `scheme`、`host` 和 `basePath` 字段定义服务器 URL：

JSONCopy  复制

```json
{
   "swagger": "2.0",
   "host": "example.com",
   "basePath": "/v1",
   "schemes": ["https"]
   ...
}
```

Semantic Kernel will construct the server URL as `https://example.com/v1`.
Semantic Kernel将以 `https://example.com/v1` 构造服务器 URL。

In contrast, OpenAPI v3 documents define the server URL using the `servers` field:
相比之下，OpenAPI v3 文档使用 `servers` 字段定义服务器 URL：

JSONCopy  复制

```json
{
   "openapi": "3.0.1",
   "servers": [
      {
         "url": "https://example.com/v1"
      }
   ],
   ...
}
```

Semantic Kernel will use the first server URL specified in the document as the base URL: `https://example.com/v1`.
Semantic Kernel将使用文档中指定的第一个服务器 URL 作为基本 URL：`https://example.com/v1`。

OpenAPI v3 also allows for parameterized server URLs using variables indicated by curly braces:
OpenAPI v3 还允许使用大括号表示的变量来参数化服务器 URL：

JSONCopy  复制

```json
{
   "openapi": "3.0.1",
   "servers": [
      {
         "url": "https://{environment}.example.com/v1",
         "variables": {
            "environment": {
               "default": "prod"
            }
         }
      }
   ],
   ...  
}
```

In this case, Semantic Kernel will replace the variable placeholder with either the value provided as an argument for the variable or the default value if no argument is provided, resulting in the URL: `https://prod.example.com/v1`.
在这种情况下，Semantic Kernel会将变量占位符替换为作为变量参数提供的值，或者如果未提供参数，则使用默认值，从而生成 URL：`https://prod.example.com/v1`。

If the OpenAPI document specifies no server URL, Semantic Kernel will use the base URL of the server from which the OpenAPI document was loaded:
如果 OpenAPI 文档未指定服务器 URL，则Semantic Kernel将使用从中加载 OpenAPI 文档的服务器的基本 URL：

C#Copy  复制

```csharp
await kernel.ImportPluginFromOpenApiAsync(pluginName: "lights", uri: new Uri("https://api-host.com/swagger.json"));
```

The base URL will be `https://api-host.com`.
基本 URL 将 `https://api-host.com`。



### Overriding the Server URL 覆盖服务器 URL

In some instances, the server URL specified in the OpenAPI document or the server from which the document was loaded may not be suitable for use cases involving the OpenAPI plugin.
在某些情况下，OpenAPI 文档中指定的服务器 URL 或从中加载文档的服务器可能不适合涉及 OpenAPI 插件的用例。

Semantic Kernel allows you to override the server URL by providing a custom base URL when adding the OpenAPI plugin to the kernel:
Semantic Kernel允许您在将 OpenAPI 插件添加到内核时通过提供自定义基本 URL 来覆盖服务器 URL：

C#Copy  复制

```csharp
await kernel.ImportPluginFromOpenApiAsync(  
    pluginName: "lights",  
    uri: new Uri("https://example.com/v1/swagger.json"),  
    executionParameters: new OpenApiFunctionExecutionParameters()  
    {  
        ServerUrlOverride = new Uri("https://custom-server.com/v1")  
    });  
```

In this example, the base URL will be `https://custom-server.com/v1`, overriding the server URL specified in the OpenAPI document and the server URL from which the document was loaded.
在此示例中，将 `https://custom-server.com/v1` 基本 URL，覆盖 OpenAPI 文档中指定的服务器 URL 和从中加载文档的服务器 URL。



## Authentication  认证

Most REST APIs require authentication to access their resources. Semantic Kernel provides a mechanism that enables you to integrate a variety of authentication methods required by OpenAPI plugins.
大多数 REST API 都需要身份验证才能访问其资源。Semantic Kernel提供了一种机制，使您能够集成 OpenAPI 插件所需的各种身份验证方法。

This mechanism relies on an authentication callback function, which is invoked before each API request. This callback function has access to the HttpRequestMessage object, representing the HTTP request that will be sent to the API. You can use this object to add authentication credentials to the request. The credentials can be added as headers, query parameters, or in the request body, depending on the authentication method used by the API.
此机制依赖于身份验证回调函数，该函数在每个 API 请求之前调用。此回调函数可以访问 HttpRequestMessage 对象，该对象表示将发送到 API 的 HTTP 请求。您可以使用此对象向请求添加身份验证凭据。凭据可以添加为标头、查询参数或添加到请求正文中，具体取决于 API 使用的身份验证方法。

You need to register this callback function when adding the OpenAPI plugin to the kernel. The following code snippet demonstrates how to register it to authenticate requests:
在将 OpenAPI 插件添加到内核时，您需要注册此回调函数。以下代码片段演示了如何注册它以验证请求：

C#Copy  复制

```csharp
static Task AuthenticateRequestAsyncCallback(HttpRequestMessage request, CancellationToken cancellationToken = default)
{
    // Best Practices:  
    // * Store sensitive information securely, using environment variables or secure configuration management systems.  
    // * Avoid hardcoding sensitive information directly in your source code.  
    // * Regularly rotate tokens and API keys, and revoke any that are no longer in use.  
    // * Use HTTPS to encrypt the transmission of any sensitive information to prevent interception.  

    // Example of Bearer Token Authentication  
    // string token = "your_access_token";  
    // request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", token);  

    // Example of API Key Authentication  
    // string apiKey = "your_api_key";  
    // request.Headers.Add("X-API-Key", apiKey);    

    return Task.CompletedTask;  
}

await kernel.ImportPluginFromOpenApiAsync(  
    pluginName: "lights",  
    uri: new Uri("https://example.com/v1/swagger.json"),  
    executionParameters: new OpenApiFunctionExecutionParameters()  
    {  
        AuthCallback = AuthenticateRequestAsyncCallback
    });  
```

For more complex authentication scenarios that require dynamic access to the details of the authentication schemas supported by an API, you can use document and operation metadata to obtain this information. For more details, see [Document and operation metadata](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins#document-and-operation-metadata).
对于需要动态访问 API 支持的身份验证架构详细信息的更复杂的身份验证场景，您可以使用文档和作元数据来获取此信息。有关更多详细信息，请参阅[文档和作元数据 ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins#document-and-operation-metadata)。



## Response content reading customization 响应内容阅读自定义

Semantic Kernel has a built-in mechanism for reading the content of HTTP responses from OpenAPI plugins and converting them to the appropriate .NET data types. For example, an image response can be read as a byte array, while a JSON or XML response can be read as a string.
Semantic Kernel具有内置机制，用于从 OpenAPI 插件读取 HTTP 响应的内容并将其转换为适当的 .NET 数据类型。例如，图像响应可以作为字节数组读取，而 JSON 或 XML 响应可以作为字符串读取。

However, there may be cases when the built-in mechanism is insufficient for your needs. For instance, when the response is a large JSON object or image that needs to be read as a stream in order to be supplied as input to another API. In such cases, reading the response content as a string or byte array and then converting it back to a stream can be inefficient and may lead to performance issues. To address this, Semantic Kernel allows for response content reading customization by providing a custom content reader:
但是，在某些情况下，内置机制可能不足以满足您的需求。例如，当响应是一个大型 JSON 对象或图像时，需要将其读取为流才能作为另一个 API 的输入提供。在这种情况下，将响应内容读取为字符串或字节数组，然后将其转换回流可能效率低下，并可能导致性能问题。为了解决这个问题，Semantic Kernel允许通过提供自定义内容阅读器来自定义响应内容读取：

C#Copy  复制

```csharp
private static async Task<object?> ReadHttpResponseContentAsync(HttpResponseContentReaderContext context, CancellationToken cancellationToken)  
{  
    // Read JSON content as a stream instead of as a string, which is the default behavior.  
    if (context.Response.Content.Headers.ContentType?.MediaType == "application/json")  
    {  
        return await context.Response.Content.ReadAsStreamAsync(cancellationToken);  
    }  

    // HTTP request and response properties can be used to determine how to read the content.  
    if (context.Request.Headers.Contains("x-stream"))  
    {  
        return await context.Response.Content.ReadAsStreamAsync(cancellationToken);  
    }  

    // Return null to indicate that any other HTTP content not handled above should be read by the default reader.  
    return null;  
}  

await kernel.ImportPluginFromOpenApiAsync(  
    pluginName: "lights",  
    uri: new Uri("https://example.com/v1/swagger.json"),  
    executionParameters: new OpenApiFunctionExecutionParameters()  
    {  
        HttpResponseContentReader = ReadHttpResponseContentAsync  
    });  
```

In this example, the `ReadHttpResponseContentAsync` method reads the HTTP response content as a stream when the content type is `application/json` or when the request contains a custom header `x-stream`. The method returns `null` for any other content types, indicating that the default content reader should be used.
在此示例中，当内容类型为 `application/json` 或请求包含自定义标头 `x-stream` 时，`ReadHttpResponseContentAsync` 方法将 HTTP 响应内容读取为流。该方法为任何其他内容类型返回 `null`，指示应使用默认内容阅读器。



## Document and operation metadata 文档和作元数据

Semantic Kernel extracts OpenAPI document and operation metadata, including API information, security schemas, operation ID, description, parameter metadata and many more. It provides access to this information through the `KernelFunction.Metadata.AdditionalParameters` property. This metadata can be useful in scenarios where additional information about the API or operation is required, such as for authentication purposes:
Semantic Kernel 提取 OpenAPI 文档和作元数据，包括 API 信息、安全模式、作 ID、描述、参数元数据等。它通过 `KernelFunction.Metadata.AdditionalParameters` 该物业提供对此信息的访问。此元数据在需要有关 API 或作的其他信息的情况下非常有用，例如出于身份验证目的：

C#Copy  复制

```csharp
static async Task AuthenticateRequestAsyncCallbackAsync(HttpRequestMessage request, CancellationToken cancellationToken = default)
{
    // Get the function context
    if (request.Options.TryGetValue(OpenApiKernelFunctionContext.KernelFunctionContextKey, out OpenApiKernelFunctionContext? functionContext))
    {
        // Get the operation metadata
        if (functionContext!.Function!.Metadata.AdditionalProperties["operation"] is RestApiOperation operation)
        {
            // Handle API key-based authentication
            IEnumerable<KeyValuePair<RestApiSecurityScheme, IList<string>>> apiKeySchemes = operation.SecurityRequirements.Select(requirement => requirement.FirstOrDefault(schema => schema.Key.SecuritySchemeType == "apiKey"));
            if (apiKeySchemes.Any())
            {
                (RestApiSecurityScheme scheme, IList<string> scopes) = apiKeySchemes.First();

                // Get the API key for the scheme and scopes from your app identity provider
                var apiKey = await this.identityProvider.GetApiKeyAsync(scheme, scopes);

                // Add the API key to the request headers
                if (scheme.In == RestApiParameterLocation.Header)
                {
                    request.Headers.Add(scheme.Name, apiKey);
                }
                else if (scheme.In == RestApiParameterLocation.Query)
                {
                    request.RequestUri = new Uri($"{request.RequestUri}?{scheme.Name}={apiKey}");
                }
                else
                {
                    throw new NotSupportedException($"API key location '{scheme.In}' is not supported.");
                }
            }

            // Handle other authentication types like Basic, Bearer, OAuth2, etc. For more information, see https://swagger.io/docs/specification/v3_0/authentication/
        }
    }
}

// Import the transformed OpenAPI plugin specification
var plugin = kernel.ImportPluginFromOpenApi(
    pluginName: "lights",
    uri: new Uri("https://example.com/v1/swagger.json"),
    new OpenApiFunctionExecutionParameters()
    {
        AuthCallback = AuthenticateRequestAsyncCallbackAsync
    });

await kernel.InvokePromptAsync("Test");
```

In this example, the `AuthenticateRequestAsyncCallbackAsync` method reads the operation metadata from the function context and extracts the security requirements for the operation to determine the authentication scheme. It then retrieves the API key, for the scheme and scopes, from the app identity provider and adds it to the request headers or query parameters.
在此示例中，该 `AuthenticateRequestAsyncCallbackAsync` 方法从函数上下文中读取作元数据，并提取作的安全要求以确定身份验证方案。然后，它从应用标识提供者检索方案和范围的 API 密钥，并将其添加到请求标头或查询参数中。

The following table lists the metadata available in the `KernelFunction.Metadata.AdditionalParameters` dictionary:
下表列出了 `KernelFunction.Metadata.AdditionalParameters` 字典中可用的元数据：

  展开表

| Key  钥匙       | Type  类型                          | Description  描述                                            |
| :-------------- | :---------------------------------- | :----------------------------------------------------------- |
| info  信息      | `RestApiInfo`                       | API information, including title, description, and version. API 信息，包括标题、描述和版本。 |
| operation  操作 | `RestApiOperation`                  | API operation details, such as id, description, path, method, etc. API 作详细信息，例如 id、描述、路径、方法等。 |
| security  安全  | IList<`RestApiSecurityRequirement`> | API security requirements - type, name, in, etc. API 安全要求 - 类型、名称、输入等。 |



## Tips and tricks for adding OpenAPI plugins 添加 OpenAPI 插件的提示和技巧

Since OpenAPI specifications are typically designed for humans, you may need to make some alterations to make them easier for an AI to understand. Here are some tips and tricks to help you do that:
由于 OpenAPI 规范通常是为人类设计的，因此您可能需要进行一些更改以使 AI 更容易理解它们。以下是一些帮助您做到这一点的提示和技巧：

  展开表

| Recommendation  建议                                         | Description  描述                                            |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Version control your API specifications版本控制您的 API 规范** | Instead of pointing to a live API specification, consider checking-in and versioning your Swagger file. This will allow your AI researchers to test (and alter) the API specification used by the AI agent without affecting the live API and vice versa. 不要指向实时 API 规范，而是考虑签入和版本控制您的 Swagger 文件。这将允许您的 AI 研究人员测试（和更改）AI 代理使用的 API 规范，而不会影响实时 API，反之亦然。 |
| **Limit the number of endpoints限制端点数量**                | Try to limit the number of endpoints in your API. Consolidate similar functionalities into single endpoints with optional parameters to reduce complexity. 尝试限制 API 中的端点数量。将类似的功能整合到具有可选参数的单个端点中，以降低复杂性。 |
| **Use descriptive names for endpoints and parameters对终结点和参数使用描述性名称** | Ensure that the names of your endpoints and parameters are descriptive and self-explanatory. This helps the AI understand their purpose without needing extensive explanations. 确保终结点和参数的名称具有描述性和不言自明。这有助于人工智能理解其目的，而无需进行大量解释。 |
| **Use consistent naming conventions使用一致的命名约定**      | Maintain consistent naming conventions throughout your API. This reduces confusion and helps the AI learn and predict the structure of your API more easily. 在整个 API 中保持一致的命名约定。这减少了混乱，并帮助 AI 更轻松地学习和预测 API 的结构。 |
| **Simplify your API specifications简化您的 API 规范**        | Often, OpenAPI specifications are very detailed and include a lot of information that isn't necessary for the AI agent to help a user. The simpler the API, the fewer tokens you need to spend to describe it, and the fewer tokens the AI needs to send requests to it. 通常，OpenAPI 规范非常详细，包含大量 AI 代理帮助用户不需要的信息。API 越简单，描述它所需的令牌就越少，AI 向其发送请求所需的令牌就越少。 |
| **Avoid string parameters  避免使用字符串参数**              | When possible, avoid using string parameters in your API. Instead, use more specific types like integers, booleans, or enums. This will help the AI understand the API better. 如果可能，请避免在 API 中使用字符串参数。相反，请使用更具体的类型，例如整数、布尔值或枚举。这将有助于人工智能更好地理解 API。 |
| **Provide examples in descriptions在描述中提供示例**         | When humans use Swagger files, they typically are able to test the API using the Swagger UI, which includes sample requests and responses. Since the AI agent can't do this, consider providing examples in the descriptions of the parameters. 当人类使用 Swagger 文件时，他们通常能够使用 Swagger UI（包括示例请求和响应）测试 API。由于 AI 代理无法执行此作，请考虑在参数描述中提供示例。 |
| **Reference other endpoints in descriptions在描述中引用其他端点** | Often, AIs will confuse similar endpoints. To help the AI differentiate between endpoints, consider referencing other endpoints in the descriptions. For example, you could say "This endpoint is similar to the `get_all_lights` endpoint, but it only returns a single light." 通常，人工智能会混淆类似的端点。为了帮助 AI 区分终结点，请考虑在说明中引用其他终结点。例如，您可以说“此终结点类似于 `get_all_lights` 终结点，但它只返回一个灯。 |
| **Provide helpful error messages提供有用的错误消息**         | While not within the OpenAPI specification, consider providing error messages that help the AI self-correct. For example, if a user provides an invalid ID, consider providing an error message that suggests the AI agent get the correct ID from the `get_all_lights` endpoint. 虽然不在 OpenAPI 规范范围内，但请考虑提供帮助 AI 自我纠正的错误消息。例如，如果用户提供了无效的 ID，请考虑提供一条错误消息，建议 AI 代理从 `get_all_lights` 终结点获取正确的 ID。 |



## Next steps  后续步骤

Now that you know how to create a plugin, you can now learn how to use them with your AI agent. Depending on the type of functions you've added to your plugins, there are different patterns you should follow. For retrieval functions, refer to the [using retrieval functions](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag) article. For task automation functions, refer to the [using task automation functions](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-task-automation-functions) article.
现在您已经知道如何创建插件，您现在可以学习如何将它们与您的 AI 代理一起使用。根据您添加到插件的功能类型，您应该遵循不同的模式。有关检索函数，请参阅[使用检索函数](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag)一文。有关任务自动化函数，请参阅[使用任务自动化函数](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-task-automation-functions)一文。