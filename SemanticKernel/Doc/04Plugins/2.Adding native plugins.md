# Add native code as a plugin 将本机代码添加为插件

- 03/07/2025

The easiest way to provide an AI agent with capabilities that are not natively supported is to wrap native code into a plugin. This allows you to leverage your existing skills as an app developer to extend the capabilities of your AI agents.
为 AI 代理提供本机不支持的功能的最简单方法是将本机代码包装到插件中。这使您可以利用您作为应用程序开发人员的现有技能来扩展 AI 代理的功能。

Behind the scenes, Semantic Kernel will then use the descriptions you provide, along with reflection, to semantically describe the plugin to the AI agent. This allows the AI agent to understand the capabilities of the plugin and how to interact with it.
在幕后，Semantic Kernel将使用您提供的描述以及反射，以语义方式向 AI 代理描述插件。这使得 AI 代理能够了解插件的功能以及如何与其交互。



## Providing the LLM with the right information 为 LLM 提供正确的信息

When authoring a plugin, you need to provide the AI agent with the right information to understand the capabilities of the plugin and its functions. This includes:
在创作插件时，您需要向 AI 代理提供正确的信息，以了解插件的功能及其功能。这包括：

- The name of the plugin
  插件的名称
- The names of the functions
  函数的名称
- The descriptions of the functions
  功能说明
- The parameters of the functions
  函数的参数
- The schema of the parameters
  参数的架构
- The schema of the return value
  返回值的架构

The value of Semantic Kernel is that it can automatically generate most of this information from the code itself. As a developer, this just means that you must provide the semantic descriptions of the functions and parameters so the AI agent can understand them. If you properly comment and annotate your code, however, you likely already have this information on hand.
Semantic Kernel的价值在于它可以从代码本身自动生成大部分信息。作为开发人员，这只是意味着您必须提供函数和参数的语义描述，以便 AI 代理能够理解它们。但是，如果您正确地注释和注释代码，您可能已经掌握了此信息。

Below, we'll walk through the two different ways of providing your AI agent with native code and how to provide this semantic information.
下面，我们将介绍向 AI 代理提供本机代码的两种不同方法，以及如何提供此语义信息。



### Defining a plugin using a class 使用类定义插件

The easiest way to create a native plugin is to start with a class and then add methods annotated with the `KernelFunction` attribute. It is also recommended to liberally use the `Description` annotation to provide the AI agent with the necessary information to understand the function.
创建原生插件的最简单方法是从类开始，然后添加带有 `KernelFunction` 属性注释的方法。还建议大量使用 `Description` 注释，为 AI 代理提供理解函数所需的信息。

 Tip  提示

The following `LightsPlugin` uses the `LightModel` defined [here](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/#1-define-your-plugin).
以下 `LightsPlugin` 使用[此处](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/#1-define-your-plugin)定义的 `LightModel`。

C#Copy  复制

```csharp
public class LightsPlugin
{
   private readonly List<LightModel> _lights;

   public LightsPlugin(LoggerFactory loggerFactory, List<LightModel> lights)
   {
      _lights = lights;
   }

   [KernelFunction("get_lights")]
   [Description("Gets a list of lights and their current state")]
   public async Task<List<LightModel>> GetLightsAsync()
   {
      return _lights;
   }

   [KernelFunction("change_state")]
   [Description("Changes the state of the light")]
   public async Task<LightModel?> ChangeStateAsync(LightModel changeState)
   {
      // Find the light to change
      var light = _lights.FirstOrDefault(l => l.Id == changeState.Id);

      // If the light does not exist, return null
      if (light == null)
      {
         return null;
      }

      // Update the light state
      light.IsOn = changeState.IsOn;
      light.Brightness = changeState.Brightness;
      light.Color = changeState.Color;

      return light;
   }
}
```

 Tip  提示

Because the LLMs are predominantly trained on Python code, it is recommended to use snake_case for function names and parameters (even if you're using C# or Java). This will help the AI agent better understand the function and its parameters.
由于 LLM 主要在 Python 代码上进行训练，因此建议对函数名称和参数使用 snake_case（即使您使用的是 C# 或 Java）。这将有助于 AI 代理更好地理解函数及其参数。

 Tip  提示

Your functions can specify `Kernel`, `KernelArguments`, `ILoggerFactory`, `ILogger`, `IAIServiceSelector`, `CultureInfo`, `IFormatProvider`, `CancellationToken` as parameters and these will not be advertised to the LLM and will be automatically set when the function is called. If you rely on `KernelArguments` instead of explicit input arguments then your code will be responsible for performing type conversions.
函数可以将 `Kernel`、`KernelArguments、``ILoggerFactory`、`ILogger`、`IAIServiceSelector`、`CultureInfo`、`IFormatProvider`、`CancellationToken` 指定为参数，这些参数不会播发给 LLM，而是在调用函数时自动设置。如果您依赖于 `KernelArguments` 而不是显式输入参数，那么您的代码将负责执行类型转换。

If your function has a complex object as an input variable, Semantic Kernel will also generate a schema for that object and pass it to the AI agent. Similar to functions, you should provide `Description` annotations for properties that are non-obvious to the AI. Below is the definition for the `LightState` class and the `Brightness` enum.
如果您的函数具有复杂对象作为输入变量，Semantic Kernel还将为该对象生成模式并将其传递给 AI 代理。与函数类似，应为 AI 不明显的属性提供 `Description` 注释。下面是 `LightState` 类和 `Brightness` 枚举的定义。

C#Copy  复制

```csharp
using System.Text.Json.Serialization;

public class LightModel
{
   [JsonPropertyName("id")]
   public int Id { get; set; }

   [JsonPropertyName("name")]
   public string? Name { get; set; }

   [JsonPropertyName("is_on")]
   public bool? IsOn { get; set; }

   [JsonPropertyName("brightness")]
   public Brightness? Brightness { get; set; }

   [JsonPropertyName("color")]
   [Description("The color of the light with a hex code (ensure you include the # symbol)")]
   public string? Color { get; set; }
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum Brightness
{
   Low,
   Medium,
   High
}
```

 Note  注意

While this is a "fun" example, it does a good job showing just how complex a plugin's parameters can be. In this single case, we have a complex object with *four* different types of properties: an integer, string, boolean, and enum. Semantic Kernel's value is that it can automatically generate the schema for this object and pass it to the AI agent and marshal the parameters generated by the AI agent into the correct object.
虽然这是一个“有趣”的例子，但它很好地展示了插件参数的复杂性。在这个单一情况下，我们有一个具有*四*种不同类型属性的复杂对象：整数、字符串、布尔值和枚举。Semantic Kernel 的价值在于，它可以自动生成该对象的 schema 并将其传递给 AI 代理，并将 AI 代理生成的参数编组到正确的对象中。

Once you're done authoring your plugin class, you can add it to the kernel using the `AddFromType<>` or `AddFromObject` methods.
创作插件类后，可以使用 `AddFromType<>` 或 `AddFromObject` 方法将其添加到内核中。

 Tip  提示

When creating a function, always ask yourself "how can I give the AI additional help to use this function?" This can include using specific input types (avoid strings where possible), providing descriptions, and examples.
创建函数时，请始终问自己“如何为人工智能提供额外的帮助来使用此函数？这可以包括使用特定的输入类型（尽可能避免使用字符串）、提供描述和示例。



#### Adding a plugin using the `AddFromObject` method 使用 `AddFromObject` 方法添加插件

The `AddFromObject` method allows you to add an instance of the plugin class directly to the plugin collection in case you want to directly control how the plugin is constructed.
`AddFromObject` 方法允许您将插件类的实例直接添加到插件集合中，以防您想要直接控制插件的构造方式。

For example, the constructor of the `LightsPlugin` class requires the list of lights. In this case, you can create an instance of the plugin class and add it to the plugin collection.
例如，`LightsPlugin` 类的构造函数需要光源列表。在这种情况下，您可以创建插件类的实例并将其添加到插件集合中。

C#Copy  复制

```csharp
List<LightModel> lights = new()
   {
      new LightModel { Id = 1, Name = "Table Lamp", IsOn = false, Brightness = Brightness.Medium, Color = "#FFFFFF" },
      new LightModel { Id = 2, Name = "Porch light", IsOn = false, Brightness = Brightness.High, Color = "#FF0000" },
      new LightModel { Id = 3, Name = "Chandelier", IsOn = true, Brightness = Brightness.Low, Color = "#FFFF00" }
   };

kernel.Plugins.AddFromObject(new LightsPlugin(lights));
```



#### Adding a plugin using the `AddFromType<>` method 使用 `AddFromType<>` 方法添加插件

When using the `AddFromType<>` method, the kernel will automatically use dependency injection to create an instance of the plugin class and add it to the plugin collection.
使用 `AddFromType<>` 方法时，内核会自动使用依赖注入来创建插件类的实例，并将其添加到插件集合中。

This is helpful if your constructor requires services or other dependencies to be injected into the plugin. For example, our `LightsPlugin` class may require a logger and a light service to be injected into it instead of a list of lights.
如果您的构造函数需要将服务或其他依赖项注入插件，这将很有帮助。例如，我们的 `LightsPlugin` 类可能需要将记录器和光源服务注入其中，而不是光源列表。

C#Copy  复制

```csharp
public class LightsPlugin
{
   private readonly Logger _logger;
   private readonly LightService _lightService;

   public LightsPlugin(LoggerFactory loggerFactory, LightService lightService)
   {
      _logger = loggerFactory.CreateLogger<LightsPlugin>();
      _lightService = lightService;
   }

   [KernelFunction("get_lights")]
   [Description("Gets a list of lights and their current state")]
   public async Task<List<LightModel>> GetLightsAsync()
   {
      _logger.LogInformation("Getting lights");
      return lightService.GetLights();
   }

   [KernelFunction("change_state")]
   [Description("Changes the state of the light")]
   public async Task<LightModel?> ChangeStateAsync(LightModel changeState)
   {
      _logger.LogInformation("Changing light state");
      return lightService.ChangeState(changeState);
   }
}
```

With Dependency Injection, you can add the required services and plugins to the kernel builder before building the kernel.
通过依赖注入，您可以在构建内核之前将所需的服务和插件添加到内核构建器中。

C#Copy  复制

```csharp
var builder = Kernel.CreateBuilder();

// Add dependencies for the plugin
builder.Services.AddLogging(loggingBuilder => loggingBuilder.AddConsole().SetMinimumLevel(LogLevel.Trace));
builder.Services.AddSingleton<LightService>();

// Add the plugin to the kernel
builder.Plugins.AddFromType<LightsPlugin>("Lights");

// Build the kernel
Kernel kernel = builder.Build();
```



### Defining a plugin using a collection of functions 使用函数集合定义插件

Less common but still useful is defining a plugin using a collection of functions. This is particularly useful if you need to dynamically create a plugin from a set of functions at runtime.
不太常见但仍然有用的是使用函数集合定义插件。如果您需要在运行时从一组函数动态创建插件，这将特别有用。

Using this process requires you to use the function factory to create individual functions before adding them to the plugin.
使用此过程需要在将单个函数添加到插件之前使用函数工厂创建单个函数。

C#Copy  复制

```csharp
kernel.Plugins.AddFromFunctions("time_plugin",
[
    KernelFunctionFactory.CreateFromMethod(
        method: () => DateTime.Now,
        functionName: "get_time",
        description: "Get the current time"
    ),
    KernelFunctionFactory.CreateFromMethod(
        method: (DateTime start, DateTime end) => (end - start).TotalSeconds,
        functionName: "diff_time",
        description: "Get the difference between two times in seconds"
    )
]);
```



### Additional strategies for adding native code with Dependency Injection 使用依赖注入添加本机代码的其他策略

If you're working with Dependency Injection, there are additional strategies you can take to create and add plugins to the kernel. Below are some examples of how you can add a plugin using Dependency Injection.
如果您正在使用依赖注入，您可以采取其他策略来创建插件并将其添加到内核。以下是如何使用依赖注入添加插件的一些示例。



#### Inject a plugin collection 注入插件集合

 Tip  提示

We recommend making your plugin collection a transient service so that it is disposed of after each use since the plugin collection is mutable. Creating a new plugin collection for each use is cheap, so it should not be a performance concern.
我们建议将插件集合设为临时服务，以便在每次使用后将其处置，因为插件集合是可变的。为每次使用创建一个新的插件集合很便宜，因此它不应该成为性能问题。

C#Copy  复制

```csharp
var builder = Host.CreateApplicationBuilder(args);

// Create native plugin collection
builder.Services.AddTransient((serviceProvider)=>{
   KernelPluginCollection pluginCollection = [];
   pluginCollection.AddFromType<LightsPlugin>("Lights");

   return pluginCollection;
});

// Create the kernel service
builder.Services.AddTransient<Kernel>((serviceProvider)=> {
   KernelPluginCollection pluginCollection = serviceProvider.GetRequiredService<KernelPluginCollection>();

   return new Kernel(serviceProvider, pluginCollection);
});
```

 Tip  提示

As mentioned in the [kernel article](https://learn.microsoft.com/en-us/semantic-kernel/concepts/kernel), the kernel is extremely lightweight, so creating a new kernel for each use as a transient is not a performance concern.
正如[内核文章](https://learn.microsoft.com/en-us/semantic-kernel/concepts/kernel)中提到的，内核非常轻量级，因此为每次用作瞬态创建一个新内核不是性能问题。



#### Generate your plugins as singletons 将插件生成为单例

Plugins are not mutable, so its typically safe to create them as singletons. This can be done by using the plugin factory and adding the resulting plugin to your service collection.
插件是不可变的，因此将它们创建为单例通常是安全的。这可以通过使用插件工厂并将生成的插件添加到您的服务集合来完成。

C#Copy  复制

```csharp
var builder = Host.CreateApplicationBuilder(args);

// Create singletons of your plugin
builder.Services.AddKeyedSingleton("LightPlugin", (serviceProvider, key) => {
    return KernelPluginFactory.CreateFromType<LightsPlugin>();
});

// Create a kernel service with singleton plugin
builder.Services.AddTransient((serviceProvider)=> {
    KernelPluginCollection pluginCollection = [
      serviceProvider.GetRequiredKeyedService<KernelPlugin>("LightPlugin")
    ];

    return new Kernel(serviceProvider, pluginCollection);
});
```



### Providing functions return type schema to LLM 向 LLM 提供函数返回类型模式

Currently, there is no well-defined, industry-wide standard for providing function return type metadata to AI models. Until such a standard is established, the following techniques can be considered for scenarios where the names of return type properties are insufficient for LLMs to reason about their content, or where additional context or handling instructions need to be associated with the return type to model or enhance your scenarios.
目前，没有明确定义的行业范围的标准来向 AI 模型提供函数返回类型元数据。在建立此类标准之前，对于返回类型属性的名称不足以让 LLM 推理其内容，或者需要将其他上下文或处理说明与返回类型关联以建模或增强方案的方案，可以考虑以下技术。

Before employing any of these techniques, it is advisable to provide more descriptive names for the return type properties, as this is the most straightforward way to improve the LLM's understanding of the return type and is also cost-effective in terms of token usage.
在采用任何这些技术之前，建议为返回类型属性提供更具描述性的名称，因为这是提高 LLM 对返回类型理解的最直接方法，并且在令牌使用方面也具有成本效益。



#### Provide function return type information in function description 在函数描述中提供函数返回类型信息

To apply this technique, include the return type schema in the function's description attribute. The schema should detail the property names, descriptions, and types, as shown in the following example:
若要应用此技术，请在函数的描述属性中包含返回类型架构。架构应详细说明属性名称、描述和类型，如以下示例所示：

C#Copy  复制

```csharp
public class LightsPlugin
{
   [KernelFunction("change_state")]
   [Description("""Changes the state of the light and returns:
   {  
       "type": "object",
       "properties": {
           "id": { "type": "integer", "description": "Light ID" },
           "name": { "type": "string", "description": "Light name" },
           "is_on": { "type": "boolean", "description": "Is light on" },
           "brightness": { "type": "string", "enum": ["Low", "Medium", "High"], "description": "Brightness level" },
           "color": { "type": "string", "description": "Hex color code" }
       },
       "required": ["id", "name"]
   } 
   """)]
   public async Task<LightModel?> ChangeStateAsync(LightModel changeState)
   {
      ...
   }
}
```

Some models may have limitations on the size of the function description, so it is advisable to keep the schema concise and only include essential information.
某些模型可能对函数描述的大小有限制，因此建议保持模式简洁并仅包含基本信息。

In cases where type information is not critical and minimizing token consumption is a priority, consider providing a brief description of the return type in the function's description attribute instead of the full schema.
如果类型信息不重要且最小化令牌消耗是优先事项，请考虑在函数的描述属性中提供返回类型的简要说明，而不是完整的架构。

C#Copy  复制

```csharp
public class LightsPlugin
{
   [KernelFunction("change_state")]
   [Description("""Changes the state of the light and returns:
        id: light ID,
        name: light name,
        is_on: is light on,
        brightness: brightness level (Low, Medium, High),
        color: Hex color code.
    """)]
   public async Task<LightModel?> ChangeStateAsync(LightModel changeState)
   {
      ...
   }
}
```

Both approaches mentioned above require manually adding the return type schema and updating it each time the return type changes. To avoid this, consider the next technique.
上述两种方法都需要手动添加返回类型架构，并在每次返回类型更改时更新它。为避免这种情况，请考虑下一个技术。



#### Provide function return type schema as part of the function's return value 提供函数返回类型架构作为函数返回值的一部分

This technique involves supplying both the function's return value and its schema to the LLM, rather than just the return value. This allows the LLM to use the schema to reason about the properties of the return value.
此技术涉及向 LLM 提供函数的返回值及其模式，而不仅仅是返回值。这允许 LLM 使用架构来推理返回值的属性。

To implement this technique, you need to create and register an auto function invocation filter. For more details, see the [Auto Function Invocation Filter](https://learn.microsoft.com/en-us/semantic-kernel/concepts/enterprise-readiness/filters#auto-function-invocation-filter) article. This filter should wrap the function's return value in a custom object that contains both the original return value and its schema. Below is an example:
要实现此技术，您需要创建并注册自动函数调用过滤器。有关更多详细信息，请参阅[自动函数调用过滤器](https://learn.microsoft.com/en-us/semantic-kernel/concepts/enterprise-readiness/filters#auto-function-invocation-filter)一文。此筛选器应将函数的返回值包装在包含原始返回值及其架构的自定义对象中。下面是一个例子：

C#Copy  复制

```csharp
private sealed class AddReturnTypeSchemaFilter : IAutoFunctionInvocationFilter
{
    public async Task OnAutoFunctionInvocationAsync(AutoFunctionInvocationContext context, Func<AutoFunctionInvocationContext, Task> next)
    {
        await next(context); // Invoke the original function

        // Crete the result with the schema
        FunctionResultWithSchema resultWithSchema = new()
        {
            Value = context.Result.GetValue<object>(),                  // Get the original result
            Schema = context.Function.Metadata.ReturnParameter?.Schema  // Get the function return type schema
        };

        // Return the result with the schema instead of the original one
        context.Result = new FunctionResult(context.Result, resultWithSchema);
    }

    private sealed class FunctionResultWithSchema
    {
        public object? Value { get; set; }
        public KernelJsonSchema? Schema { get; set; }
    }
}

// Register the filter
Kernel kernel = new Kernel();
kernel.AutoFunctionInvocationFilters.Add(new AddReturnTypeSchemaFilter());
```

With the filter registered, you can now provide descriptions for the return type and its properties, which will be automatically extracted by Semantic Kernel:
注册过滤器后，您现在可以提供返回类型及其属性的描述，这些描述将由Semantic Kernel自动提取：

C#Copy  复制

```csharp
[Description("The state of the light")] // Equivalent to annotating the function with the [return: Description("The state of the light")] attribute
public class LightModel
{
    [JsonPropertyName("id")]
    [Description("The ID of the light")]
    public int Id { get; set; }

    [JsonPropertyName("name")]
    [Description("The name of the light")]
    public string? Name { get; set; }

    [JsonPropertyName("is_on")]
    [Description("Indicates whether the light is on")]
    public bool? IsOn { get; set; }

    [JsonPropertyName("brightness")]
    [Description("The brightness level of the light")]
    public Brightness? Brightness { get; set; }

    [JsonPropertyName("color")]
    [Description("The color of the light with a hex code (ensure you include the # symbol)")]
    public string? Color { get; set; }
}
```

This approach eliminates the need to manually provide and update the return type schema each time the return type changes, as the schema is automatically extracted by the Semantic Kernel.
这种方法无需在每次返回类型更改时手动提供和更新返回类型架构，因为Semantic Kernel会自动提取架构。



## Next steps  后续步骤

Now that you know how to create a plugin, you can now learn how to use them with your AI agent. Depending on the type of functions you've added to your plugins, there are different patterns you should follow. For retrieval functions, refer to the [using retrieval functions](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag) article. For task automation functions, refer to the [using task automation functions](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-task-automation-functions) article.
现在您已经知道如何创建插件，您现在可以学习如何将它们与您的 AI 代理一起使用。根据您添加到插件的功能类型，您应该遵循不同的模式。有关检索函数，请参阅[使用检索函数](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag)一文。有关任务自动化函数，请参阅[使用任务自动化函数](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-task-automation-functions)一文。

[  了解如何使用检索函数](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag)