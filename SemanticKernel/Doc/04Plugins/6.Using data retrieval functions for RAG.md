# Using plugins for Retrieval Augmented Generation (RAG) 使用插件进行检索增强生成（RAG）

- 06/25/2024

Often, your AI agents must retrieve data from external sources to generate grounded responses. Without this additional context, your AI agents may hallucinate or provide incorrect information. To address this, you can use plugins to retrieve data from external sources.
通常，您的 AI 代理必须从外部源检索数据以生成有根据的响应。如果没有这些额外的上下文，您的人工智能代理可能会产生幻觉或提供不正确的信息。为了解决这个问题，您可以使用插件从外部源检索数据。

When considering plugins for Retrieval Augmented Generation (RAG), you should ask yourself two questions:
在考虑检索增强生成 （RAG） 的插件时，您应该问自己两个问题：

1. How will you (or your AI agent) "search" for the required data? Do you need [semantic search](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#semantic-search) or [classic search](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#classic-search)?
   您（或您的 AI 代理）将如何“搜索”所需的数据？您需要[语义搜索](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#semantic-search)还是[经典搜索 ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#classic-search)？
2. Do you already know the data the AI agent needs ahead of time ([pre-fetched data](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#pre-fetched-data-retrieval)), or does the AI agent need to retrieve the data [dynamically](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#dynamic-data-retrieval)?
   您是否已经提前知道 AI 代理需要的数据（[ 预取数据 ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#pre-fetched-data-retrieval)），或者 AI 代理需要[动态](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#dynamic-data-retrieval)检索数据？
3. How will you keep your data secure and [prevent oversharing of sensitive information](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#keeping-data-secure)?
   您将如何确保数据安全并[防止敏感信息过度共享 ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#keeping-data-secure)？



## Semantic vs classic search 语义搜索与经典搜索

When developing plugins for Retrieval Augmented Generation (RAG), you can use two types of search: semantic search and classic search.
在为检索增强生成 （RAG） 开发插件时，您可以使用两种类型的搜索：语义搜索和经典搜索。



### Semantic Search  语义搜索

Semantic search utilizes vector databases to understand and retrieve information based on the meaning and context of the query rather than just matching keywords. This method allows the search engine to grasp the nuances of language, such as synonyms, related concepts, and the overall intent behind a query.
语义搜索利用向量数据库根据查询的含义和上下文来理解和检索信息，而不仅仅是匹配关键字。这种方法允许搜索引擎掌握语言的细微差别，例如同义词、相关概念以及查询背后的整体意图。

Semantic search excels in environments where user queries are complex, open-ended, or require a deeper understanding of the content. For example, searching for "best smartphones for photography" would yield results that consider the context of photography features in smartphones, rather than just matching the words "best," "smartphones," and "photography."
语义搜索在用户查询复杂、开放式或需要更深入地了解内容的环境中表现出色。例如，搜索“最适合摄影的智能手机”会产生考虑智能手机中摄影功能背景的结果，而不仅仅是匹配“最佳”、“智能手机”和“摄影”这两个词。

When providing an LLM with a semantic search function, you typically only need to define a function with a single search query. The LLM will then use this function to retrieve the necessary information. Below is an example of a semantic search function that uses Azure AI Search to find documents similar to a given query.
向 LLM 提供语义搜索函数时，通常只需要使用单个搜索查询定义一个函数。然后，LLM 将使用此函数来检索必要的信息。下面是语义搜索函数的示例，该函数使用 Azure AI 搜索查找与给定查询类似的文档。

C#Copy  复制

```csharp
using System.ComponentModel;
using System.Text.Json.Serialization;
using Azure;
using Azure.Search.Documents;
using Azure.Search.Documents.Indexes;
using Azure.Search.Documents.Models;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Embeddings;

public class InternalDocumentsPlugin
{
    private readonly ITextEmbeddingGenerationService _textEmbeddingGenerationService;
    private readonly SearchIndexClient _indexClient;

    public AzureAISearchPlugin(ITextEmbeddingGenerationService textEmbeddingGenerationService, SearchIndexClient indexClient)
    {
        _textEmbeddingGenerationService = textEmbeddingGenerationService;
        _indexClient = indexClient;
    }

    [KernelFunction("Search")]
    [Description("Search for a document similar to the given query.")]
    public async Task<string> SearchAsync(string query)
    {
        // Convert string query to vector
        ReadOnlyMemory<float> embedding = await _textEmbeddingGenerationService.GenerateEmbeddingAsync(query);

        // Get client for search operations
        SearchClient searchClient = _indexClient.GetSearchClient("default-collection");

        // Configure request parameters
        VectorizedQuery vectorQuery = new(embedding);
        vectorQuery.Fields.Add("vector");

        SearchOptions searchOptions = new() { VectorSearch = new() { Queries = { vectorQuery } } };

        // Perform search request
        Response<SearchResults<IndexSchema>> response = await searchClient.SearchAsync<IndexSchema>(searchOptions);

        // Collect search results
        await foreach (SearchResult<IndexSchema> result in response.Value.GetResultsAsync())
        {
            return result.Document.Chunk; // Return text from first result
        }

        return string.Empty;
    }

    private sealed class IndexSchema
    {
        [JsonPropertyName("chunk")]
        public string Chunk { get; set; }

        [JsonPropertyName("vector")]
        public ReadOnlyMemory<float> Vector { get; set; }
    }
}
```



### Classic Search  经典搜索

Classic search, also known as attribute-based or criteria-based search, relies on filtering and matching exact terms or values within a dataset. It is particularly effective for database queries, inventory searches, and any situation where filtering by specific attributes is necessary.
经典搜索，也称为基于属性或基于条件的搜索，依赖于过滤和匹配数据集中的确切术语或值。它对于数据库查询、库存搜索以及任何需要按特定属性过滤的情况特别有效。

For example, if a user wants to find all orders placed by a particular customer ID or retrieve products within a specific price range and category, classic search provides precise and reliable results. Classic search, however, is limited by its inability to understand context or variations in language.
例如，如果用户想要查找特定客户 ID 下的所有订单或检索特定价格范围和类别内的产品，经典搜索可提供精确可靠的结果。然而，经典搜索因其无法理解上下文或语言变化而受到限制。

 Tip  提示

In most cases, your existing services already support classic search. Before implementing a semantic search, consider whether your existing services can provide the necessary context for your AI agents.
在大多数情况下，现有服务已支持经典搜索。在实施语义搜索之前，请考虑现有服务是否可以为 AI 代理提供必要的上下文。

Take for example, a plugin that retrieves customer information from a CRM system using classic search. Here, the AI simply needs to call the `GetCustomerInfoAsync` function with a customer ID to retrieve the necessary information.
以一个插件为例，它使用经典搜索从 CRM 系统检索客户信息。在这里，AI 只需使用客户 ID 调用 `GetCustomerInfoAsync` 函数即可检索必要的信息。

C#Copy  复制

```csharp
using System.ComponentModel;
using Microsoft.SemanticKernel;

public class CRMPlugin
{
    private readonly CRMService _crmService;

    public CRMPlugin(CRMService crmService)
    {
        _crmService = crmService;
    }

    [KernelFunction("GetCustomerInfo")]
    [Description("Retrieve customer information based on the given customer ID.")]
    public async Task<Customer> GetCustomerInfoAsync(string customerId)
    {
        return await _crmService.GetCustomerInfoAsync(customerId);
    }
}
```

Achieving the same search functionality with semantic search would likely be impossible or impractical due to the non-deterministic nature of semantic queries.
由于语义查询的非确定性，使用语义搜索实现相同的搜索功能可能是不可能的或不切实际的。



### When to Use Each  何时使用

Choosing between semantic and classic search depends on the nature of the query. It is ideal for content-heavy environments like knowledge bases and customer support where users might ask questions or look for products using natural language. Classic search, on the other hand, should be employed when precision and exact matches are important.
在语义搜索和经典搜索之间进行选择取决于查询的性质。它非常适合知识库和客户支持等内容密集型环境，用户可能会在这些环境中使用自然语言提出问题或寻找产品。另一方面，当精度和精确匹配很重要时，应采用经典搜索。

In some scenarios, you may need to combine both approaches to provide comprehensive search capabilities. For instance, a chatbot assisting customers in an e-commerce store might use semantic search to understand user queries and classic search to filter products based on specific attributes like price, brand, or availability.
在某些情况下，可能需要结合这两种方法来提供全面的搜索功能。例如，在电子商务商店中协助客户的聊天机器人可能会使用语义搜索来了解用户查询，并使用经典搜索根据价格、品牌或可用性等特定属性过滤产品。

Below is an example of a plugin that combines semantic and classic search to retrieve product information from an e-commerce database.
下面是一个插件示例，它结合了语义搜索和经典搜索，用于从电子商务数据库中检索产品信息。

C#Copy  复制

```csharp
using System.ComponentModel;
using Microsoft.SemanticKernel;

public class ECommercePlugin
{
    [KernelFunction("search_products")]
    [Description("Search for products based on the given query.")]
    public async Task<IEnumerable<Product>> SearchProductsAsync(string query, ProductCategories category = null, decimal? minPrice = null, decimal? maxPrice = null)
    {
        // Perform semantic and classic search with the given parameters
    }
}
```



## Dynamic vs pre-fetched data retrieval 动态数据检索与预提取数据检索

When developing plugins for Retrieval Augmented Generation (RAG), you must also consider whether the data retrieval process is static or dynamic. This allows you to optimize the performance of your AI agents by retrieving data only when necessary.
在为检索增强生成 （RAG） 开发插件时，您还必须考虑数据检索过程是静态的还是动态的。这使您可以仅在必要时检索数据来优化 AI 代理的性能。



### Dynamic data retrieval  动态数据检索

In most cases, the user query will determine the data that the AI agent needs to retrieve. For example, a user might ask for the difference between two different products. The AI agent would then need to dynamically retrieve the product information from a database or API to generate a response using [function calling](https://learn.microsoft.com/en-us/semantic-kernel/concepts/ai-services/chat-completion/function-calling/). It would be impractical to pre-fetch all possible product information ahead of time and give it to the AI agent.
在大多数情况下，用户查询将确定 AI 代理需要检索的数据。例如，用户可能会询问两种不同产品之间的差异。然后，AI 代理需要从数据库或 API 动态检索产品信息，以使用[函数调用](https://learn.microsoft.com/en-us/semantic-kernel/concepts/ai-services/chat-completion/function-calling/)生成响应。提前预取所有可能的产品信息并将其提供给 AI 代理是不切实际的。

Below is an example of a back-and-forth chat between a user and an AI agent where dynamic data retrieval is necessary.
下面是用户和 AI 代理之间需要动态数据检索的来回聊天示例。

  展开表

| Role  角色                                               | Message  消息                                                |
| :------------------------------------------------------- | :----------------------------------------------------------- |
| 🔵 **User**  🔵 **用户**                                   | Can you tell me about the best mattresses? 你能告诉我最好的床垫吗？ |
| 🔴 **Assistant (function call)** 🔴 **助手 （函数 调用）** | `Products.Search("mattresses")`                              |
| 🟢 **Tool**  🟢 **工具**                                   | `[{"id": 25323, "name": "Cloud Nine"},{"id": 63633, "name": "Best Sleep"}]` |
| 🔴 **Assistant**  🔴 **助理**                              | Sure! We have both Cloud Nine and Best Sleep 确定！我们有 Cloud Nine 和 Best Sleep |
| 🔵 **User**  🔵 **用户**                                   | What's the difference between them? 它们之间有什么区别？     |
| 🔴 **Assistant (function call)** 🔴 **助手 （函数 调用）** | `Products.GetDetails(25323)` `Products.GetDetails(63633)` `产品获取详细信息（25323）`` 产品获取详细信息（63633）` |
| 🟢 **Tool**  🟢 **工具**                                   | `{ "id": 25323, "name": "Cloud Nine", "price": 1000, "material": "Memory foam" }` |
| 🟢 **Tool**  🟢 **工具**                                   | `{ "id": 63633, "name": "Best Sleep", "price": 1200, "material": "Latex" }` |
| 🔴 **Assistant**  🔴 **助理**                              | Cloud Nine is made of memory foam and costs $1000. Best Sleep is made of latex and costs $1200. Cloud Nine 由记忆海绵制成，售价 1000 美元。Best Sleep 由乳胶制成，售价 1200 美元。 |



### Pre-fetched data Retrieval 预取数据检索

Static data retrieval involves fetching data from external sources and *always* providing it to the AI agent. This is useful when the data is required for every request or when the data is relatively stable and doesn't change frequently.
静态数据检索涉及从外部来源获取数据并*始终*将其提供给 AI 代理。当每个请求都需要数据或数据相对稳定且不经常更改时，这非常有用。

Take for example, an agent that always answers questions about the local weather. Assuming you have a `WeatherPlugin`, you can pre-fetch weather data from a weather API and provide it in the chat history. This allows the agent to generate responses about the weather without wasting time requesting the data from the API.
以一个总是回答有关当地天气问题的代理为例。假设你有一个 `WeatherPlugin`，你可以从天气 API 预提取天气数据，并在聊天记录中提供。这允许代理生成有关天气的响应，而不会浪费时间从 API 请求数据。

C#Copy  复制

```csharp
using System.Text.Json;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.ChatCompletion;

IKernelBuilder builder = Kernel.CreateBuilder();
builder.AddAzureOpenAIChatCompletion(deploymentName, endpoint, apiKey);
builder.Plugins.AddFromType<WeatherPlugin>();
Kernel kernel = builder.Build();

// Get the weather
var weather = await kernel.Plugins.GetFunction("WeatherPlugin", "get_weather").InvokeAsync(kernel);

// Initialize the chat history with the weather
ChatHistory chatHistory = new ChatHistory("The weather is:\n" + JsonSerializer.Serialize(weather));

// Simulate a user message
chatHistory.AddUserMessage("What is the weather like today?");

// Get the answer from the AI agent
IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
var result = await chatCompletionService.GetChatMessageContentAsync(chatHistory);
```



## Keeping data secure  确保数据安全

When retrieving data from external sources, it is important to ensure that the data is secure and that sensitive information is not exposed. To prevent oversharing of sensitive information, you can use the following strategies:
从外部来源检索数据时，重要的是要确保数据安全并且敏感信息不会泄露。为了防止过度共享敏感信息，您可以使用以下策略：

  展开表

| Strategy  策略                                               | Description  描述                                            |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Use the user's auth token使用用户的身份验证令牌**          | Avoid creating service principals used by the AI agent to retrieve information for users. Doing so makes it difficult to verify that a user has access to the retrieved information. 避免创建 AI 代理用于检索用户信息的服务主体。这样做将难以验证用户是否有权访问检索到的信息。 |
| **Avoid recreating search services避免重新创建搜索服务**     | Before creating a new search service with a vector DB, check if one already exists for the service that has the required data. By reusing existing services, you can avoid duplicating sensitive content, leverage existing access controls, and use existing filtering mechanisms that only return data the user has access to. 在使用矢量数据库创建新的搜索服务之前，请检查具有所需数据的服务是否已存在搜索服务。通过重用现有服务，可以避免重复敏感内容，利用现有的访问控制，并使用仅返回用户有权访问的数据的现有过滤机制。 |
| **Store reference in vector DBs instead of content将引用存储在矢量数据库中而不是内容中** | Instead of duplicating sensitive content to vector DBs, you can store references to the actual data. For a user to access this information, their auth token must first be used to retrieve the real data. 您可以存储对实际数据的引用，而不是将敏感内容复制到矢量数据库。要使用户访问此信息，必须首先使用其身份验证令牌来检索真实数据。 |



## Next steps  后续步骤

Now that you now how to ground your AI agents with data from external sources, you can now learn how to use AI agents to automate business processes. To learn more, see [using task automation functions](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-task-automation-functions).
现在，你现在如何使用来自外部源的数据来建立 AI 代理，现在可以学习如何使用 AI 代理来自动化业务流程。若要了解详细信息，请参阅[使用任务自动化函数 ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-task-automation-functions)。