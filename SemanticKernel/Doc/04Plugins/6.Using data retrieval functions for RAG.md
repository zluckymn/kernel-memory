# Using plugins for Retrieval Augmented Generation (RAG) ä½¿ç”¨æ’ä»¶è¿›è¡Œæ£€ç´¢å¢å¼ºç”Ÿæˆï¼ˆRAGï¼‰

- 06/25/2024

Often, your AI agents must retrieve data from external sources to generate grounded responses. Without this additional context, your AI agents may hallucinate or provide incorrect information. To address this, you can use plugins to retrieve data from external sources.
é€šå¸¸ï¼Œæ‚¨çš„ AI ä»£ç†å¿…é¡»ä»å¤–éƒ¨æºæ£€ç´¢æ•°æ®ä»¥ç”Ÿæˆæœ‰æ ¹æ®çš„å“åº”ã€‚å¦‚æœæ²¡æœ‰è¿™äº›é¢å¤–çš„ä¸Šä¸‹æ–‡ï¼Œæ‚¨çš„äººå·¥æ™ºèƒ½ä»£ç†å¯èƒ½ä¼šäº§ç”Ÿå¹»è§‰æˆ–æä¾›ä¸æ­£ç¡®çš„ä¿¡æ¯ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨æ’ä»¶ä»å¤–éƒ¨æºæ£€ç´¢æ•°æ®ã€‚

When considering plugins for Retrieval Augmented Generation (RAG), you should ask yourself two questions:
åœ¨è€ƒè™‘æ£€ç´¢å¢å¼ºç”Ÿæˆ ï¼ˆRAGï¼‰ çš„æ’ä»¶æ—¶ï¼Œæ‚¨åº”è¯¥é—®è‡ªå·±ä¸¤ä¸ªé—®é¢˜ï¼š

1. How will you (or your AI agent) "search" for the required data? Do you need [semantic search](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#semantic-search) or [classic search](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#classic-search)?
   æ‚¨ï¼ˆæˆ–æ‚¨çš„ AI ä»£ç†ï¼‰å°†å¦‚ä½•â€œæœç´¢â€æ‰€éœ€çš„æ•°æ®ï¼Ÿæ‚¨éœ€è¦[è¯­ä¹‰æœç´¢](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#semantic-search)è¿˜æ˜¯[ç»å…¸æœç´¢ ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#classic-search)ï¼Ÿ
2. Do you already know the data the AI agent needs ahead of time ([pre-fetched data](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#pre-fetched-data-retrieval)), or does the AI agent need to retrieve the data [dynamically](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#dynamic-data-retrieval)?
   æ‚¨æ˜¯å¦å·²ç»æå‰çŸ¥é“ AI ä»£ç†éœ€è¦çš„æ•°æ®ï¼ˆ[ é¢„å–æ•°æ® ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#pre-fetched-data-retrieval)ï¼‰ï¼Œæˆ–è€… AI ä»£ç†éœ€è¦[åŠ¨æ€](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#dynamic-data-retrieval)æ£€ç´¢æ•°æ®ï¼Ÿ
3. How will you keep your data secure and [prevent oversharing of sensitive information](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#keeping-data-secure)?
   æ‚¨å°†å¦‚ä½•ç¡®ä¿æ•°æ®å®‰å…¨å¹¶[é˜²æ­¢æ•æ„Ÿä¿¡æ¯è¿‡åº¦å…±äº« ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag#keeping-data-secure)ï¼Ÿ



## Semantic vs classic search è¯­ä¹‰æœç´¢ä¸ç»å…¸æœç´¢

When developing plugins for Retrieval Augmented Generation (RAG), you can use two types of search: semantic search and classic search.
åœ¨ä¸ºæ£€ç´¢å¢å¼ºç”Ÿæˆ ï¼ˆRAGï¼‰ å¼€å‘æ’ä»¶æ—¶ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ä¸¤ç§ç±»å‹çš„æœç´¢ï¼šè¯­ä¹‰æœç´¢å’Œç»å…¸æœç´¢ã€‚



### Semantic Search  è¯­ä¹‰æœç´¢

Semantic search utilizes vector databases to understand and retrieve information based on the meaning and context of the query rather than just matching keywords. This method allows the search engine to grasp the nuances of language, such as synonyms, related concepts, and the overall intent behind a query.
è¯­ä¹‰æœç´¢åˆ©ç”¨å‘é‡æ•°æ®åº“æ ¹æ®æŸ¥è¯¢çš„å«ä¹‰å’Œä¸Šä¸‹æ–‡æ¥ç†è§£å’Œæ£€ç´¢ä¿¡æ¯ï¼Œè€Œä¸ä»…ä»…æ˜¯åŒ¹é…å…³é”®å­—ã€‚è¿™ç§æ–¹æ³•å…è®¸æœç´¢å¼•æ“æŒæ¡è¯­è¨€çš„ç»†å¾®å·®åˆ«ï¼Œä¾‹å¦‚åŒä¹‰è¯ã€ç›¸å…³æ¦‚å¿µä»¥åŠæŸ¥è¯¢èƒŒåçš„æ•´ä½“æ„å›¾ã€‚

Semantic search excels in environments where user queries are complex, open-ended, or require a deeper understanding of the content. For example, searching for "best smartphones for photography" would yield results that consider the context of photography features in smartphones, rather than just matching the words "best," "smartphones," and "photography."
è¯­ä¹‰æœç´¢åœ¨ç”¨æˆ·æŸ¥è¯¢å¤æ‚ã€å¼€æ”¾å¼æˆ–éœ€è¦æ›´æ·±å…¥åœ°äº†è§£å†…å®¹çš„ç¯å¢ƒä¸­è¡¨ç°å‡ºè‰²ã€‚ä¾‹å¦‚ï¼Œæœç´¢â€œæœ€é€‚åˆæ‘„å½±çš„æ™ºèƒ½æ‰‹æœºâ€ä¼šäº§ç”Ÿè€ƒè™‘æ™ºèƒ½æ‰‹æœºä¸­æ‘„å½±åŠŸèƒ½èƒŒæ™¯çš„ç»“æœï¼Œè€Œä¸ä»…ä»…æ˜¯åŒ¹é…â€œæœ€ä½³â€ã€â€œæ™ºèƒ½æ‰‹æœºâ€å’Œâ€œæ‘„å½±â€è¿™ä¸¤ä¸ªè¯ã€‚

When providing an LLM with a semantic search function, you typically only need to define a function with a single search query. The LLM will then use this function to retrieve the necessary information. Below is an example of a semantic search function that uses Azure AI Search to find documents similar to a given query.
å‘ LLM æä¾›è¯­ä¹‰æœç´¢å‡½æ•°æ—¶ï¼Œé€šå¸¸åªéœ€è¦ä½¿ç”¨å•ä¸ªæœç´¢æŸ¥è¯¢å®šä¹‰ä¸€ä¸ªå‡½æ•°ã€‚ç„¶åï¼ŒLLM å°†ä½¿ç”¨æ­¤å‡½æ•°æ¥æ£€ç´¢å¿…è¦çš„ä¿¡æ¯ã€‚ä¸‹é¢æ˜¯è¯­ä¹‰æœç´¢å‡½æ•°çš„ç¤ºä¾‹ï¼Œè¯¥å‡½æ•°ä½¿ç”¨ Azure AI æœç´¢æŸ¥æ‰¾ä¸ç»™å®šæŸ¥è¯¢ç±»ä¼¼çš„æ–‡æ¡£ã€‚

C#Copy  å¤åˆ¶

```csharp
using System.ComponentModel;
using System.Text.Json.Serialization;
using Azure;
using Azure.Search.Documents;
using Azure.Search.Documents.Indexes;
using Azure.Search.Documents.Models;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Embeddings;

public class InternalDocumentsPlugin
{
    private readonly ITextEmbeddingGenerationService _textEmbeddingGenerationService;
    private readonly SearchIndexClient _indexClient;

    public AzureAISearchPlugin(ITextEmbeddingGenerationService textEmbeddingGenerationService, SearchIndexClient indexClient)
    {
        _textEmbeddingGenerationService = textEmbeddingGenerationService;
        _indexClient = indexClient;
    }

    [KernelFunction("Search")]
    [Description("Search for a document similar to the given query.")]
    public async Task<string> SearchAsync(string query)
    {
        // Convert string query to vector
        ReadOnlyMemory<float> embedding = await _textEmbeddingGenerationService.GenerateEmbeddingAsync(query);

        // Get client for search operations
        SearchClient searchClient = _indexClient.GetSearchClient("default-collection");

        // Configure request parameters
        VectorizedQuery vectorQuery = new(embedding);
        vectorQuery.Fields.Add("vector");

        SearchOptions searchOptions = new() { VectorSearch = new() { Queries = { vectorQuery } } };

        // Perform search request
        Response<SearchResults<IndexSchema>> response = await searchClient.SearchAsync<IndexSchema>(searchOptions);

        // Collect search results
        await foreach (SearchResult<IndexSchema> result in response.Value.GetResultsAsync())
        {
            return result.Document.Chunk; // Return text from first result
        }

        return string.Empty;
    }

    private sealed class IndexSchema
    {
        [JsonPropertyName("chunk")]
        public string Chunk { get; set; }

        [JsonPropertyName("vector")]
        public ReadOnlyMemory<float> Vector { get; set; }
    }
}
```



### Classic Search  ç»å…¸æœç´¢

Classic search, also known as attribute-based or criteria-based search, relies on filtering and matching exact terms or values within a dataset. It is particularly effective for database queries, inventory searches, and any situation where filtering by specific attributes is necessary.
ç»å…¸æœç´¢ï¼Œä¹Ÿç§°ä¸ºåŸºäºå±æ€§æˆ–åŸºäºæ¡ä»¶çš„æœç´¢ï¼Œä¾èµ–äºè¿‡æ»¤å’ŒåŒ¹é…æ•°æ®é›†ä¸­çš„ç¡®åˆ‡æœ¯è¯­æˆ–å€¼ã€‚å®ƒå¯¹äºæ•°æ®åº“æŸ¥è¯¢ã€åº“å­˜æœç´¢ä»¥åŠä»»ä½•éœ€è¦æŒ‰ç‰¹å®šå±æ€§è¿‡æ»¤çš„æƒ…å†µç‰¹åˆ«æœ‰æ•ˆã€‚

For example, if a user wants to find all orders placed by a particular customer ID or retrieve products within a specific price range and category, classic search provides precise and reliable results. Classic search, however, is limited by its inability to understand context or variations in language.
ä¾‹å¦‚ï¼Œå¦‚æœç”¨æˆ·æƒ³è¦æŸ¥æ‰¾ç‰¹å®šå®¢æˆ· ID ä¸‹çš„æ‰€æœ‰è®¢å•æˆ–æ£€ç´¢ç‰¹å®šä»·æ ¼èŒƒå›´å’Œç±»åˆ«å†…çš„äº§å“ï¼Œç»å…¸æœç´¢å¯æä¾›ç²¾ç¡®å¯é çš„ç»“æœã€‚ç„¶è€Œï¼Œç»å…¸æœç´¢å› å…¶æ— æ³•ç†è§£ä¸Šä¸‹æ–‡æˆ–è¯­è¨€å˜åŒ–è€Œå—åˆ°é™åˆ¶ã€‚

 Tip  æç¤º

In most cases, your existing services already support classic search. Before implementing a semantic search, consider whether your existing services can provide the necessary context for your AI agents.
åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œç°æœ‰æœåŠ¡å·²æ”¯æŒç»å…¸æœç´¢ã€‚åœ¨å®æ–½è¯­ä¹‰æœç´¢ä¹‹å‰ï¼Œè¯·è€ƒè™‘ç°æœ‰æœåŠ¡æ˜¯å¦å¯ä»¥ä¸º AI ä»£ç†æä¾›å¿…è¦çš„ä¸Šä¸‹æ–‡ã€‚

Take for example, a plugin that retrieves customer information from a CRM system using classic search. Here, the AI simply needs to call the `GetCustomerInfoAsync` function with a customer ID to retrieve the necessary information.
ä»¥ä¸€ä¸ªæ’ä»¶ä¸ºä¾‹ï¼Œå®ƒä½¿ç”¨ç»å…¸æœç´¢ä» CRM ç³»ç»Ÿæ£€ç´¢å®¢æˆ·ä¿¡æ¯ã€‚åœ¨è¿™é‡Œï¼ŒAI åªéœ€ä½¿ç”¨å®¢æˆ· ID è°ƒç”¨ `GetCustomerInfoAsync` å‡½æ•°å³å¯æ£€ç´¢å¿…è¦çš„ä¿¡æ¯ã€‚

C#Copy  å¤åˆ¶

```csharp
using System.ComponentModel;
using Microsoft.SemanticKernel;

public class CRMPlugin
{
    private readonly CRMService _crmService;

    public CRMPlugin(CRMService crmService)
    {
        _crmService = crmService;
    }

    [KernelFunction("GetCustomerInfo")]
    [Description("Retrieve customer information based on the given customer ID.")]
    public async Task<Customer> GetCustomerInfoAsync(string customerId)
    {
        return await _crmService.GetCustomerInfoAsync(customerId);
    }
}
```

Achieving the same search functionality with semantic search would likely be impossible or impractical due to the non-deterministic nature of semantic queries.
ç”±äºè¯­ä¹‰æŸ¥è¯¢çš„éç¡®å®šæ€§ï¼Œä½¿ç”¨è¯­ä¹‰æœç´¢å®ç°ç›¸åŒçš„æœç´¢åŠŸèƒ½å¯èƒ½æ˜¯ä¸å¯èƒ½çš„æˆ–ä¸åˆ‡å®é™…çš„ã€‚



### When to Use Each  ä½•æ—¶ä½¿ç”¨

Choosing between semantic and classic search depends on the nature of the query. It is ideal for content-heavy environments like knowledge bases and customer support where users might ask questions or look for products using natural language. Classic search, on the other hand, should be employed when precision and exact matches are important.
åœ¨è¯­ä¹‰æœç´¢å’Œç»å…¸æœç´¢ä¹‹é—´è¿›è¡Œé€‰æ‹©å–å†³äºæŸ¥è¯¢çš„æ€§è´¨ã€‚å®ƒéå¸¸é€‚åˆçŸ¥è¯†åº“å’Œå®¢æˆ·æ”¯æŒç­‰å†…å®¹å¯†é›†å‹ç¯å¢ƒï¼Œç”¨æˆ·å¯èƒ½ä¼šåœ¨è¿™äº›ç¯å¢ƒä¸­ä½¿ç”¨è‡ªç„¶è¯­è¨€æå‡ºé—®é¢˜æˆ–å¯»æ‰¾äº§å“ã€‚å¦ä¸€æ–¹é¢ï¼Œå½“ç²¾åº¦å’Œç²¾ç¡®åŒ¹é…å¾ˆé‡è¦æ—¶ï¼Œåº”é‡‡ç”¨ç»å…¸æœç´¢ã€‚

In some scenarios, you may need to combine both approaches to provide comprehensive search capabilities. For instance, a chatbot assisting customers in an e-commerce store might use semantic search to understand user queries and classic search to filter products based on specific attributes like price, brand, or availability.
åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¯èƒ½éœ€è¦ç»“åˆè¿™ä¸¤ç§æ–¹æ³•æ¥æä¾›å…¨é¢çš„æœç´¢åŠŸèƒ½ã€‚ä¾‹å¦‚ï¼Œåœ¨ç”µå­å•†åŠ¡å•†åº—ä¸­ååŠ©å®¢æˆ·çš„èŠå¤©æœºå™¨äººå¯èƒ½ä¼šä½¿ç”¨è¯­ä¹‰æœç´¢æ¥äº†è§£ç”¨æˆ·æŸ¥è¯¢ï¼Œå¹¶ä½¿ç”¨ç»å…¸æœç´¢æ ¹æ®ä»·æ ¼ã€å“ç‰Œæˆ–å¯ç”¨æ€§ç­‰ç‰¹å®šå±æ€§è¿‡æ»¤äº§å“ã€‚

Below is an example of a plugin that combines semantic and classic search to retrieve product information from an e-commerce database.
ä¸‹é¢æ˜¯ä¸€ä¸ªæ’ä»¶ç¤ºä¾‹ï¼Œå®ƒç»“åˆäº†è¯­ä¹‰æœç´¢å’Œç»å…¸æœç´¢ï¼Œç”¨äºä»ç”µå­å•†åŠ¡æ•°æ®åº“ä¸­æ£€ç´¢äº§å“ä¿¡æ¯ã€‚

C#Copy  å¤åˆ¶

```csharp
using System.ComponentModel;
using Microsoft.SemanticKernel;

public class ECommercePlugin
{
    [KernelFunction("search_products")]
    [Description("Search for products based on the given query.")]
    public async Task<IEnumerable<Product>> SearchProductsAsync(string query, ProductCategories category = null, decimal? minPrice = null, decimal? maxPrice = null)
    {
        // Perform semantic and classic search with the given parameters
    }
}
```



## Dynamic vs pre-fetched data retrieval åŠ¨æ€æ•°æ®æ£€ç´¢ä¸é¢„æå–æ•°æ®æ£€ç´¢

When developing plugins for Retrieval Augmented Generation (RAG), you must also consider whether the data retrieval process is static or dynamic. This allows you to optimize the performance of your AI agents by retrieving data only when necessary.
åœ¨ä¸ºæ£€ç´¢å¢å¼ºç”Ÿæˆ ï¼ˆRAGï¼‰ å¼€å‘æ’ä»¶æ—¶ï¼Œæ‚¨è¿˜å¿…é¡»è€ƒè™‘æ•°æ®æ£€ç´¢è¿‡ç¨‹æ˜¯é™æ€çš„è¿˜æ˜¯åŠ¨æ€çš„ã€‚è¿™ä½¿æ‚¨å¯ä»¥ä»…åœ¨å¿…è¦æ—¶æ£€ç´¢æ•°æ®æ¥ä¼˜åŒ– AI ä»£ç†çš„æ€§èƒ½ã€‚



### Dynamic data retrieval  åŠ¨æ€æ•°æ®æ£€ç´¢

In most cases, the user query will determine the data that the AI agent needs to retrieve. For example, a user might ask for the difference between two different products. The AI agent would then need to dynamically retrieve the product information from a database or API to generate a response using [function calling](https://learn.microsoft.com/en-us/semantic-kernel/concepts/ai-services/chat-completion/function-calling/). It would be impractical to pre-fetch all possible product information ahead of time and give it to the AI agent.
åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œç”¨æˆ·æŸ¥è¯¢å°†ç¡®å®š AI ä»£ç†éœ€è¦æ£€ç´¢çš„æ•°æ®ã€‚ä¾‹å¦‚ï¼Œç”¨æˆ·å¯èƒ½ä¼šè¯¢é—®ä¸¤ç§ä¸åŒäº§å“ä¹‹é—´çš„å·®å¼‚ã€‚ç„¶åï¼ŒAI ä»£ç†éœ€è¦ä»æ•°æ®åº“æˆ– API åŠ¨æ€æ£€ç´¢äº§å“ä¿¡æ¯ï¼Œä»¥ä½¿ç”¨[å‡½æ•°è°ƒç”¨](https://learn.microsoft.com/en-us/semantic-kernel/concepts/ai-services/chat-completion/function-calling/)ç”Ÿæˆå“åº”ã€‚æå‰é¢„å–æ‰€æœ‰å¯èƒ½çš„äº§å“ä¿¡æ¯å¹¶å°†å…¶æä¾›ç»™ AI ä»£ç†æ˜¯ä¸åˆ‡å®é™…çš„ã€‚

Below is an example of a back-and-forth chat between a user and an AI agent where dynamic data retrieval is necessary.
ä¸‹é¢æ˜¯ç”¨æˆ·å’Œ AI ä»£ç†ä¹‹é—´éœ€è¦åŠ¨æ€æ•°æ®æ£€ç´¢çš„æ¥å›èŠå¤©ç¤ºä¾‹ã€‚

  å±•å¼€è¡¨

| Role  è§’è‰²                                               | Message  æ¶ˆæ¯                                                |
| :------------------------------------------------------- | :----------------------------------------------------------- |
| ğŸ”µ **User**  ğŸ”µ **ç”¨æˆ·**                                   | Can you tell me about the best mattresses? ä½ èƒ½å‘Šè¯‰æˆ‘æœ€å¥½çš„åºŠå«å—ï¼Ÿ |
| ğŸ”´ **Assistant (function call)** ğŸ”´ **åŠ©æ‰‹ ï¼ˆå‡½æ•° è°ƒç”¨ï¼‰** | `Products.Search("mattresses")`                              |
| ğŸŸ¢ **Tool**  ğŸŸ¢ **å·¥å…·**                                   | `[{"id": 25323, "name": "Cloud Nine"},{"id": 63633, "name": "Best Sleep"}]` |
| ğŸ”´ **Assistant**  ğŸ”´ **åŠ©ç†**                              | Sure! We have both Cloud Nine and Best Sleep ç¡®å®šï¼æˆ‘ä»¬æœ‰ Cloud Nine å’Œ Best Sleep |
| ğŸ”µ **User**  ğŸ”µ **ç”¨æˆ·**                                   | What's the difference between them? å®ƒä»¬ä¹‹é—´æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ     |
| ğŸ”´ **Assistant (function call)** ğŸ”´ **åŠ©æ‰‹ ï¼ˆå‡½æ•° è°ƒç”¨ï¼‰** | `Products.GetDetails(25323)` `Products.GetDetails(63633)` `äº§å“è·å–è¯¦ç»†ä¿¡æ¯ï¼ˆ25323ï¼‰`` äº§å“è·å–è¯¦ç»†ä¿¡æ¯ï¼ˆ63633ï¼‰` |
| ğŸŸ¢ **Tool**  ğŸŸ¢ **å·¥å…·**                                   | `{ "id": 25323, "name": "Cloud Nine", "price": 1000, "material": "Memory foam" }` |
| ğŸŸ¢ **Tool**  ğŸŸ¢ **å·¥å…·**                                   | `{ "id": 63633, "name": "Best Sleep", "price": 1200, "material": "Latex" }` |
| ğŸ”´ **Assistant**  ğŸ”´ **åŠ©ç†**                              | Cloud Nine is made of memory foam and costs $1000. Best Sleep is made of latex and costs $1200. Cloud Nine ç”±è®°å¿†æµ·ç»µåˆ¶æˆï¼Œå”®ä»· 1000 ç¾å…ƒã€‚Best Sleep ç”±ä¹³èƒ¶åˆ¶æˆï¼Œå”®ä»· 1200 ç¾å…ƒã€‚ |



### Pre-fetched data Retrieval é¢„å–æ•°æ®æ£€ç´¢

Static data retrieval involves fetching data from external sources and *always* providing it to the AI agent. This is useful when the data is required for every request or when the data is relatively stable and doesn't change frequently.
é™æ€æ•°æ®æ£€ç´¢æ¶‰åŠä»å¤–éƒ¨æ¥æºè·å–æ•°æ®å¹¶*å§‹ç»ˆ*å°†å…¶æä¾›ç»™ AI ä»£ç†ã€‚å½“æ¯ä¸ªè¯·æ±‚éƒ½éœ€è¦æ•°æ®æˆ–æ•°æ®ç›¸å¯¹ç¨³å®šä¸”ä¸ç»å¸¸æ›´æ”¹æ—¶ï¼Œè¿™éå¸¸æœ‰ç”¨ã€‚

Take for example, an agent that always answers questions about the local weather. Assuming you have a `WeatherPlugin`, you can pre-fetch weather data from a weather API and provide it in the chat history. This allows the agent to generate responses about the weather without wasting time requesting the data from the API.
ä»¥ä¸€ä¸ªæ€»æ˜¯å›ç­”æœ‰å…³å½“åœ°å¤©æ°”é—®é¢˜çš„ä»£ç†ä¸ºä¾‹ã€‚å‡è®¾ä½ æœ‰ä¸€ä¸ª `WeatherPlugin`ï¼Œä½ å¯ä»¥ä»å¤©æ°” API é¢„æå–å¤©æ°”æ•°æ®ï¼Œå¹¶åœ¨èŠå¤©è®°å½•ä¸­æä¾›ã€‚è¿™å…è®¸ä»£ç†ç”Ÿæˆæœ‰å…³å¤©æ°”çš„å“åº”ï¼Œè€Œä¸ä¼šæµªè´¹æ—¶é—´ä» API è¯·æ±‚æ•°æ®ã€‚

C#Copy  å¤åˆ¶

```csharp
using System.Text.Json;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.ChatCompletion;

IKernelBuilder builder = Kernel.CreateBuilder();
builder.AddAzureOpenAIChatCompletion(deploymentName, endpoint, apiKey);
builder.Plugins.AddFromType<WeatherPlugin>();
Kernel kernel = builder.Build();

// Get the weather
var weather = await kernel.Plugins.GetFunction("WeatherPlugin", "get_weather").InvokeAsync(kernel);

// Initialize the chat history with the weather
ChatHistory chatHistory = new ChatHistory("The weather is:\n" + JsonSerializer.Serialize(weather));

// Simulate a user message
chatHistory.AddUserMessage("What is the weather like today?");

// Get the answer from the AI agent
IChatCompletionService chatCompletionService = kernel.GetRequiredService<IChatCompletionService>();
var result = await chatCompletionService.GetChatMessageContentAsync(chatHistory);
```



## Keeping data secure  ç¡®ä¿æ•°æ®å®‰å…¨

When retrieving data from external sources, it is important to ensure that the data is secure and that sensitive information is not exposed. To prevent oversharing of sensitive information, you can use the following strategies:
ä»å¤–éƒ¨æ¥æºæ£€ç´¢æ•°æ®æ—¶ï¼Œé‡è¦çš„æ˜¯è¦ç¡®ä¿æ•°æ®å®‰å…¨å¹¶ä¸”æ•æ„Ÿä¿¡æ¯ä¸ä¼šæ³„éœ²ã€‚ä¸ºäº†é˜²æ­¢è¿‡åº¦å…±äº«æ•æ„Ÿä¿¡æ¯ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ç­–ç•¥ï¼š

  å±•å¼€è¡¨

| Strategy  ç­–ç•¥                                               | Description  æè¿°                                            |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Use the user's auth tokenä½¿ç”¨ç”¨æˆ·çš„èº«ä»½éªŒè¯ä»¤ç‰Œ**          | Avoid creating service principals used by the AI agent to retrieve information for users. Doing so makes it difficult to verify that a user has access to the retrieved information. é¿å…åˆ›å»º AI ä»£ç†ç”¨äºæ£€ç´¢ç”¨æˆ·ä¿¡æ¯çš„æœåŠ¡ä¸»ä½“ã€‚è¿™æ ·åšå°†éš¾ä»¥éªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒè®¿é—®æ£€ç´¢åˆ°çš„ä¿¡æ¯ã€‚ |
| **Avoid recreating search servicesé¿å…é‡æ–°åˆ›å»ºæœç´¢æœåŠ¡**     | Before creating a new search service with a vector DB, check if one already exists for the service that has the required data. By reusing existing services, you can avoid duplicating sensitive content, leverage existing access controls, and use existing filtering mechanisms that only return data the user has access to. åœ¨ä½¿ç”¨çŸ¢é‡æ•°æ®åº“åˆ›å»ºæ–°çš„æœç´¢æœåŠ¡ä¹‹å‰ï¼Œè¯·æ£€æŸ¥å…·æœ‰æ‰€éœ€æ•°æ®çš„æœåŠ¡æ˜¯å¦å·²å­˜åœ¨æœç´¢æœåŠ¡ã€‚é€šè¿‡é‡ç”¨ç°æœ‰æœåŠ¡ï¼Œå¯ä»¥é¿å…é‡å¤æ•æ„Ÿå†…å®¹ï¼Œåˆ©ç”¨ç°æœ‰çš„è®¿é—®æ§åˆ¶ï¼Œå¹¶ä½¿ç”¨ä»…è¿”å›ç”¨æˆ·æœ‰æƒè®¿é—®çš„æ•°æ®çš„ç°æœ‰è¿‡æ»¤æœºåˆ¶ã€‚ |
| **Store reference in vector DBs instead of contentå°†å¼•ç”¨å­˜å‚¨åœ¨çŸ¢é‡æ•°æ®åº“ä¸­è€Œä¸æ˜¯å†…å®¹ä¸­** | Instead of duplicating sensitive content to vector DBs, you can store references to the actual data. For a user to access this information, their auth token must first be used to retrieve the real data. æ‚¨å¯ä»¥å­˜å‚¨å¯¹å®é™…æ•°æ®çš„å¼•ç”¨ï¼Œè€Œä¸æ˜¯å°†æ•æ„Ÿå†…å®¹å¤åˆ¶åˆ°çŸ¢é‡æ•°æ®åº“ã€‚è¦ä½¿ç”¨æˆ·è®¿é—®æ­¤ä¿¡æ¯ï¼Œå¿…é¡»é¦–å…ˆä½¿ç”¨å…¶èº«ä»½éªŒè¯ä»¤ç‰Œæ¥æ£€ç´¢çœŸå®æ•°æ®ã€‚ |



## Next steps  åç»­æ­¥éª¤

Now that you now how to ground your AI agents with data from external sources, you can now learn how to use AI agents to automate business processes. To learn more, see [using task automation functions](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-task-automation-functions).
ç°åœ¨ï¼Œä½ ç°åœ¨å¦‚ä½•ä½¿ç”¨æ¥è‡ªå¤–éƒ¨æºçš„æ•°æ®æ¥å»ºç«‹ AI ä»£ç†ï¼Œç°åœ¨å¯ä»¥å­¦ä¹ å¦‚ä½•ä½¿ç”¨ AI ä»£ç†æ¥è‡ªåŠ¨åŒ–ä¸šåŠ¡æµç¨‹ã€‚è‹¥è¦äº†è§£è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…[ä½¿ç”¨ä»»åŠ¡è‡ªåŠ¨åŒ–å‡½æ•° ](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-task-automation-functions)ã€‚