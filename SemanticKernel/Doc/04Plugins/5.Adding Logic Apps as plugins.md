# Add Logic Apps as plugins 将逻辑应用添加为插件

- 06/25/2024

Often in an enterprise, you already have a set of workflows that perform real work in Logic Apps. These could be used by other automation services or power front-end applications that humans interact with. In Semantic Kernel, you can add these exact same workflows as plugins so your agents can also use them.
通常，在企业中，你已经有一组在逻辑应用中执行实际工作的工作流。这些可以由其他自动化服务或为人类交互的前端应用程序提供动力。在Semantic Kernel中，您可以将这些完全相同的工作流程添加为插件，以便您的代理也可以使用它们。

Take for example the Logic Apps workflows used by the Semantic Kernel team to answer questions about new PRs. With the following workflows, an agent has everything it needs to retrieve code changes, search for related files, and check failure logs.
以Semantic Kernel团队用来回答有关新 PR 的问题的逻辑应用工作流为例。通过以下工作流，代理拥有检索代码更改、搜索相关文件和检查失败日志所需的一切。

![Logic Apps](https://learn.microsoft.com/en-us/semantic-kernel/media/logic-apps-workflows.png)

- **Search files** – to find code snippets that are relevant to a given problem
  **搜索文件** – 查找与给定问题相关的代码片段
- **Get file** – to retrieve the contents of a file in the GitHub repository
  **获取文件** – 检索 GitHub 存储库中文件的内容
- **Get PR details** – to retrieve the details of a PR (e.g., the PR title, description, and author)
  **获取 PR 详细信息** – 检索 PR 的详细信息（例如，PR 标题、描述和作者）
- **Get PR files** – to retrieve the files that were changed in a PR
  **获取 PR 文件** – 检索在 PR 中更改的文件
- **Get build and test failures** – to retrieve the build and test failures for a given GitHub action run
  **获取生成和测试失败** – 检索给定 GitHub 作运行的生成和测试失败
- **Get log file** – to retrieve the log file for a given GitHub action run
  **获取日志文件** – 检索给定 GitHub 作运行的日志文件

Leveraging Logic Apps for Semantic Kernel plugins is also a great way to take advantage of the over [1,400 connectors available in Logic Apps](https://learn.microsoft.com/en-us/connectors/connector-reference/connector-reference-logicapps-connectors). This means you can easily connect to a wide variety of services and systems without writing any code.
利用逻辑应用的Semantic Kernel插件也是利用[逻辑应用中提供的 1,400 多个连接器](https://learn.microsoft.com/en-us/connectors/connector-reference/connector-reference-logicapps-connectors)的好方法。这意味着您无需编写任何代码即可轻松连接到各种服务和系统。

 Important  重要

Today, you can only add standard Logic Apps (also known as single-tenant Logic Apps) as plugins. Consumption Logic Apps are coming soon.
目前，只能将标准逻辑应用（也称为单租户逻辑应用）添加为插件。消耗逻辑应用即将推出。



## Importing Logic Apps as plugins 将逻辑应用导入为插件

To add Logic Apps workflows to Semantic Kernel, you'll use the same methods as loading in an [OpenAPI specifications](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins). Below is some sample code.
若要将逻辑应用工作流添加到Semantic Kernel，将使用与在 [OpenAPI 规范](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/adding-openapi-plugins)中加载相同的方法。下面是一些示例代码。

C#Copy  复制

```csharp
await kernel.ImportPluginFromOpenApiAsync(
    pluginName: "openapi_plugin",
    uri: new Uri("https://example.azurewebsites.net/swagger.json"),
    executionParameters: new OpenApiFunctionExecutionParameters()
    {
        // Determines whether payload parameter names are augmented with namespaces.
        // Namespaces prevent naming conflicts by adding the parent parameter name
        // as a prefix, separated by dots
        EnablePayloadNamespacing = true
    }
);
```



## Setting up Logic Apps for Semantic Kernel 为Semantic Kernel设置逻辑应用

Before you can import a Logic App as a plugin, you must first set up the Logic App to be accessible by Semantic Kernel. This involves enabling metadata endpoints and configuring your application for Easy Auth before finally importing the Logic App as a plugin with authentication.
在将逻辑应用导入为插件之前，必须先将逻辑应用设置为可由Semantic Kernel访问。这涉及启用元数据终结点并为应用程序配置 Easy Auth，然后最终将逻辑应用导入为具有身份验证的插件。



### Enable metadata endpoints 启用元数据终结点

For the easiest setup, you can enable unauthenticated access to the metadata endpoints for your Logic App. This will allow you to import your Logic App as a plugin into Semantic Kernel without needing to create a custom HTTP client to handle authentication for the initial import.
为了实现最简单的设置，可以启用对逻辑应用元数据终结点的未经身份验证的访问。这将允许你将逻辑应用作为插件导入到Semantic Kernel中，而无需创建自定义 HTTP 客户端来处理初始导入的身份验证。

The below host.json file will create two unauthenticated endpoints. You can do this in azure portal by [going to kudu console and editing the host.json file](https://learn.microsoft.com/en-us/azure/logic-apps/edit-app-settings-host-settings?tabs=azure-portal#manage-host-settings---hostjson) located at *C:\home\site\wwwroot\host.json*.
以下 host.json 文件将创建两个未经身份验证的终结点。可以在 Azure 门户中执行此作，方法是[转到 kudu 控制台并编辑](https://learn.microsoft.com/en-us/azure/logic-apps/edit-app-settings-host-settings?tabs=azure-portal#manage-host-settings---hostjson)位于 *C：\home\site\wwwroot\host.json* 的 host.json 文件。

JSONCopy  复制

```json
{ 
  "version": "2.0", 
  "extensionBundle": { 
    "id": "Microsoft.Azure.Functions.ExtensionBundle.Workflows", 
    "version": "[1.*, 2.0.0)" 
  }, 
  "extensions": { 
    "http": { 
      "routePrefix": "" 
    }, 
    "workflow": { 
      "MetadataEndpoints": { 
        "plugin": { 
          "enable": true, 
          "Authentication":{ 
              "Type":"Anonymous" 
          } 
        }, 
        "openapi": { 
          "enable": true, 
          "Authentication":{ 
              "Type":"Anonymous" 
          } 
        } 
      }, 
      "Settings": { 
        "Runtime.Triggers.RequestTriggerDefaultApiVersion": "2020-05-01-preview" 
      } 
    } 
  } 
} 
```



### Configure your application for Easy Auth 配置应用程序以进行 Easy Auth

You now want to secure your Logic App workflows so only authorized users can access them. You can do this by enabling Easy Auth on your Logic App. This will allow you to use the same authentication mechanism as your other Azure services, making it easier to manage your security policies.
现在，你想要保护逻辑应用工作流，以便只有授权用户才能访问它们。可以通过在逻辑应用上启用 Easy Auth 来执行此作。这将允许你使用与其他 Azure 服务相同的身份验证机制，从而更轻松地管理安全策略。

For an in-depth walkthrough on setting up Easy Auth, refer to this tutorial titled [Trigger workflows in Standard logic apps with Easy Auth](https://techcommunity.microsoft.com/t5/azure-integration-services-blog/trigger-workflows-in-standard-logic-apps-with-easy-auth/ba-p/3207378).
有关设置 Easy Auth 的深入演练，请参阅标题为使用 [Easy Auth 在标准逻辑应用中触发工作流](https://techcommunity.microsoft.com/t5/azure-integration-services-blog/trigger-workflows-in-standard-logic-apps-with-easy-auth/ba-p/3207378)的教程。

For those already familiar with Easy Auth (and already have an Entra client app you want to use), this is the configuration you’ll want to post to Azure management.
对于已熟悉 Easy Auth（并且已有要使用的 Entra 客户端应用）的用户，这是要发布到 Azure 管理的配置。

Bash  猛击Copy  复制

```bash
#!/bin/bash

# Variables
subscription_id="[SUBSCRIPTION_ID]"
resource_group="[RESOURCE_GROUP]"
app_name="[APP_NAME]"
api_version="2022-03-01"
arm_token="[ARM_TOKEN]"
tenant_id="[TENANT_ID]"
aad_client_id="[AAD_CLIENT_ID]"
object_ids=("[OBJECT_ID_FOR_USER1]" "[OBJECT_ID_FOR_USER2]" "[OBJECT_ID_FOR_APP1]")

# Convert the object_ids array to a JSON array
object_ids_json=$(printf '%s\n' "${object_ids[@]}" | jq -R . | jq -s .)

# Request URL
url="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$resource_group/providers/Microsoft.Web/sites/$app_name/config/authsettingsV2?api-version=$api_version"

# JSON payload
json_payload=$(cat <<EOF
{
    "properties": {
        "platform": {
            "enabled": true,
            "runtimeVersion": "~1"
        },
        "globalValidation": {
            "requireAuthentication": true,
            "unauthenticatedClientAction": "AllowAnonymous"
        },
        "identityProviders": {
            "azureActiveDirectory": {
                "enabled": true,
                "registration": {
                    "openIdIssuer": "https://sts.windows.net/$tenant_id/",
                    "clientId": "$aad_client_id"
                },
                "validation": {
                    "jwtClaimChecks": {},
                    "allowedAudiences": [
                        "api://$aad_client_id"
                    ],
                    "defaultAuthorizationPolicy": {
                        "allowedPrincipals": {
                            "identities": $object_ids_json
                        }
                    }
                }
            },
            "facebook": {
                "enabled": false,
                "registration": {},
                "login": {}
            },
            "gitHub": {
                "enabled": false,
                "registration": {},
                "login": {}
            },
            "google": {
                "enabled": false,
                "registration": {},
                "login": {},
                "validation": {}
            },
            "twitter": {
                "enabled": false,
                "registration": {}
            },
            "legacyMicrosoftAccount": {
                "enabled": false,
                "registration": {},
                "login": {},
                "validation": {}
            },
            "apple": {
                "enabled": false,
                "registration": {},
                "login": {}
            }
        }
    }
}
EOF
)

# HTTP PUT request
curl -X PUT "$url" \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $arm_token" \
    -d "$json_payload"
```



### Use Logic Apps with Semantic Kernel as a plugin 将逻辑应用与Semantic Kernel用作插件

Now that you have your Logic App secured and the metadata endpoints enabled, you’ve finished all the hard parts. You can now import your Logic App as a plugin into Semantic Kernel using the OpenAPI import method.
现在，你已保护逻辑应用并启用元数据终结点，你已完成所有困难部分。现在可以使用 OpenAPI 导入方法将逻辑应用作为插件导入到Semantic Kernel中。

When you create your plugin, you’ll want to provide a custom HTTP client that can handle the authentication for your Logic App. This will allow you to use the plugin in your AI agents without needing to worry about the authentication.
创建插件时，需要提供一个自定义 HTTP 客户端，用于处理逻辑应用的身份验证。这将允许您在 AI 代理中使用该插件，而无需担心身份验证。

Below is an example in C# that leverages interactive auth to acquire a token and authenticate the user for the Logic App.
下面是 C# 中的一个示例，它利用交互式身份验证来获取令牌并对逻辑应用的用户进行身份验证。

C#Copy  复制

```csharp
string ClientId = "[AAD_CLIENT_ID]";
string TenantId = "[TENANT_ID]";
string Authority = $"https://login.microsoftonline.com/{TenantId}";
string[] Scopes = new string[] { "api://[AAD_CLIENT_ID]/SKLogicApp" };

var app = PublicClientApplicationBuilder.Create(ClientId)
            .WithAuthority(Authority)
            .WithDefaultRedirectUri() // Uses http://localhost for a console app
            .Build();

AuthenticationResult authResult = null;
try
{
    authResult = await app.AcquireTokenInteractive(Scopes).ExecuteAsync();
}
catch (MsalException ex)
{
    Console.WriteLine("An error occurred acquiring the token: " + ex.Message);
}

// Add the plugin to the kernel with a custom HTTP client for authentication
kernel.Plugins.Add(await kernel.ImportPluginFromOpenApiAsync(
    pluginName: "[NAME_OF_PLUGIN]",
    uri: new Uri("https://[LOGIC_APP_NAME].azurewebsites.net/swagger.json"),
    executionParameters: new OpenApiFunctionExecutionParameters()
    {
        HttpClient = new HttpClient()
        {
            DefaultRequestHeaders =
            {
                Authorization = new AuthenticationHeaderValue("Bearer", authResult.AccessToken)
            }
        },
    }
));
```



## Next steps  后续步骤

Now that you know how to create a plugin, you can now learn how to use them with your AI agent. Depending on the type of functions you've added to your plugins, there are different patterns you should follow. For retrieval functions, refer to the [using retrieval functions](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag) article. For task automation functions, refer to the [using task automation functions](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-task-automation-functions) article.
现在您已经知道如何创建插件，您现在可以学习如何将它们与您的 AI 代理一起使用。根据您添加到插件的功能类型，您应该遵循不同的模式。有关检索函数，请参阅[使用检索函数](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag)一文。有关任务自动化函数，请参阅[使用任务自动化函数](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-task-automation-functions)一文。

[  了解如何使用检索函数](https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/using-data-retrieval-functions-for-rag)